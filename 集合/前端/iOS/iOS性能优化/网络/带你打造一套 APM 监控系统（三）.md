# [å¸¦ä½ æ‰“é€ ä¸€å¥— APM ç›‘æ§ç³»ç»Ÿï¼ˆä¸‰ï¼‰](http://www.gsnice.com/2020/07/%E5%B8%A6%E4%BD%A0%E6%89%93%E9%80%A0%E4%B8%80%E5%A5%97-APM-%E7%9B%91%E6%8E%A7%E7%B3%BB%E7%BB%9F-%E4%B8%89/)



## äº”ã€ App ç½‘ç»œç›‘æ§

ç§»åŠ¨ç½‘ç»œç¯å¢ƒä¸€ç›´å¾ˆå¤æ‚ï¼ŒWIFIã€2Gã€3Gã€4Gã€5G ç­‰ï¼Œç”¨æˆ·ä½¿ç”¨ App çš„è¿‡ç¨‹ä¸­å¯èƒ½åœ¨è¿™å‡ ç§ç±»å‹ä¹‹é—´åˆ‡æ¢ï¼Œè¿™ä¹Ÿæ˜¯ç§»åŠ¨ç½‘ç»œå’Œä¼ ç»Ÿç½‘ç»œé—´çš„ä¸€ä¸ªåŒºåˆ«ï¼Œè¢«ç§°ä¸ºã€ŒConnection Migrationã€ã€‚æ­¤å¤–è¿˜å­˜åœ¨ DNS è§£æç¼“æ…¢ã€å¤±è´¥ç‡é«˜ã€è¿è¥å•†åŠ«æŒç­‰é—®é¢˜ã€‚ç”¨æˆ·åœ¨ä½¿ç”¨ App æ—¶å› ä¸ºæŸäº›åŸå› å¯¼è‡´ä½“éªŒå¾ˆå·®ï¼Œè¦æƒ³é’ˆå¯¹ç½‘ç»œæƒ…å†µè¿›è¡Œæ”¹å–„ï¼Œå¿…é¡»æœ‰æ¸…æ™°çš„ç›‘æ§æ‰‹æ®µã€‚

### 1. App ç½‘ç»œè¯·æ±‚è¿‡ç¨‹

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094410663.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

**App å‘é€ä¸€æ¬¡ç½‘ç»œè¯·æ±‚ä¸€èˆ¬ä¼šç»å†ä¸‹é¢å‡ ä¸ªå…³é”®æ­¥éª¤ï¼š**

- DNS è§£æ

  Domain Name systemï¼Œç½‘ç»œåŸŸååç§°ç³»ç»Ÿï¼Œæœ¬è´¨ä¸Šå°±æ˜¯å°†`åŸŸå`å’Œ`IP åœ°å€` ç›¸äº’æ˜ å°„çš„ä¸€ä¸ªåˆ†å¸ƒå¼æ•°æ®åº“ï¼Œä½¿äººä»¬æ›´æ–¹ä¾¿çš„è®¿é—®äº’è”ç½‘ã€‚é¦–å…ˆä¼šæŸ¥è¯¢æœ¬åœ°çš„ DNS ç¼“å­˜ï¼ŒæŸ¥æ‰¾å¤±è´¥å°±å» DNS æœåŠ¡å™¨æŸ¥è¯¢ï¼Œè¿™å…¶ä¸­å¯èƒ½ä¼šç»è¿‡éå¸¸å¤šçš„èŠ‚ç‚¹ï¼Œæ¶‰åŠåˆ°**é€’å½’æŸ¥è¯¢å’Œè¿­ä»£æŸ¥è¯¢**çš„è¿‡ç¨‹ã€‚è¿è¥å•†å¯èƒ½ä¸å¹²äººäº‹ï¼šä¸€ç§æƒ…å†µå°±æ˜¯å‡ºç°è¿è¥å•†åŠ«æŒçš„ç°è±¡ï¼Œè¡¨ç°ä¸ºä½ åœ¨ App å†…è®¿é—®æŸä¸ªç½‘é¡µçš„æ—¶å€™ä¼šçœ‹åˆ°å’Œå†…å®¹ä¸ç›¸å…³çš„å¹¿å‘Šï¼›å¦ä¸€ç§å¯èƒ½çš„æƒ…å†µå°±æ˜¯æŠŠä½ çš„è¯·æ±‚ä¸¢ç»™éå¸¸è¿œçš„åŸºç«™å»åš DNS è§£æï¼Œå¯¼è‡´æˆ‘ä»¬ App çš„ DNS è§£ææ—¶é—´è¾ƒé•¿ï¼ŒApp ç½‘ç»œæ•ˆç‡ä½ã€‚ä¸€èˆ¬åš HTTPDNS æ–¹æ¡ˆå»è‡ªè¡Œè§£å†³ DNS çš„é—®é¢˜ã€‚

- TCP 3æ¬¡æ¡æ‰‹

  å…³äº TCP æ¡æ‰‹è¿‡ç¨‹ä¸­ä¸ºä»€ä¹ˆæ˜¯3æ¬¡æ¡æ‰‹è€Œä¸æ˜¯2æ¬¡ã€4æ¬¡ï¼Œå¯ä»¥æŸ¥çœ‹è¿™ç¯‡[æ–‡ç« ](https://draveness.me/whys-the-design-tcp-three-way-handshake/)ã€‚

- TLS æ¡æ‰‹

  å¯¹äº HTTPS è¯·æ±‚è¿˜éœ€è¦åš TLS æ¡æ‰‹ï¼Œä¹Ÿå°±æ˜¯å¯†é’¥åå•†çš„è¿‡ç¨‹ã€‚

- å‘é€è¯·æ±‚

  è¿æ¥å»ºç«‹å¥½ä¹‹åå°±å¯ä»¥å‘é€ requestï¼Œæ­¤æ—¶å¯ä»¥è®°å½•ä¸‹ request start æ—¶é—´

- ç­‰å¾…å›åº”

  ç­‰å¾…æœåŠ¡å™¨è¿”å›å“åº”ã€‚è¿™ä¸ªæ—¶é—´ä¸»è¦å–å†³äºèµ„æºå¤§å°ï¼Œä¹Ÿæ˜¯ç½‘ç»œè¯·æ±‚è¿‡ç¨‹ä¸­æœ€ä¸ºè€—æ—¶çš„ä¸€ä¸ªé˜¶æ®µã€‚

- è¿”å›å“åº”

  æœåŠ¡ç«¯è¿”å›å“åº”ç»™å®¢æˆ·ç«¯ï¼Œæ ¹æ® HTTP header ä¿¡æ¯ä¸­çš„çŠ¶æ€ç åˆ¤æ–­æœ¬æ¬¡è¯·æ±‚æ˜¯å¦æˆåŠŸã€æ˜¯å¦èµ°ç¼“å­˜ã€æ˜¯å¦éœ€è¦é‡å®šå‘ã€‚

### 2. ç›‘æ§åŸç†

|      åç§°       |          è¯´æ˜           |
| :-------------: | :---------------------: |
| NSURLConnection |  å·²ç»è¢«åºŸå¼ƒã€‚ç”¨æ³•ç®€å•   |
|  NSURLSession   | iOS7.0 æ¨å‡ºï¼ŒåŠŸèƒ½æ›´å¼ºå¤§ |
|    CFNetwork    | NSURL çš„åº•å±‚ï¼Œçº¯ C å®ç° |

**iOS ç½‘ç»œæ¡†æ¶å±‚çº§å…³ç³»å¦‚ä¸‹ï¼š**

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/2020071409444421.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

iOS ç½‘ç»œç°çŠ¶æ˜¯ç”±4å±‚ç»„æˆçš„ï¼šæœ€åº•å±‚çš„ BSD Socketsã€SecureTransportï¼›æ¬¡çº§åº•å±‚æ˜¯ CFNetworkã€NSURLSessionã€NSURLConnectionã€WebView æ˜¯ç”¨ Objective-C å®ç°çš„ï¼Œä¸”è°ƒç”¨ CFNetworkï¼›åº”ç”¨å±‚æ¡†æ¶ AFNetworking åŸºäº NSURLSessionã€NSURLConnection å®ç°ã€‚

ç›®å‰ä¸šç•Œå¯¹äºç½‘ç»œç›‘æ§ä¸»è¦æœ‰2ç§ï¼šä¸€ç§æ˜¯é€šè¿‡ NSURLProtocol ç›‘æ§ã€ä¸€ç§æ˜¯é€šè¿‡ Hook æ¥ç›‘æ§ã€‚ä¸‹é¢ä»‹ç»å‡ ç§åŠæ³•æ¥ç›‘æ§ç½‘ç»œè¯·æ±‚ï¼Œå„æœ‰ä¼˜ç¼ºç‚¹ã€‚

#### 2.1 æ–¹æ¡ˆä¸€ï¼šNSURLProtocol ç›‘æ§ App ç½‘ç»œè¯·æ±‚

NSURLProtocol ä½œä¸ºä¸Šå±‚æ¥å£ï¼Œä½¿ç”¨è¾ƒä¸ºç®€å•ï¼Œä½† NSURLProtocol å±äº URL Loading System ä½“ç³»ä¸­ã€‚åº”ç”¨åè®®çš„æ”¯æŒç¨‹åº¦æœ‰é™ï¼Œæ”¯æŒ FTPã€HTTPã€HTTPS ç­‰å‡ ä¸ªåº”ç”¨å±‚åè®®ï¼Œå¯¹äºå…¶ä»–çš„åè®®åˆ™æ— æ³•ç›‘æ§ï¼Œå­˜åœ¨ä¸€å®šçš„å±€é™æ€§ã€‚å¦‚æœç›‘æ§åº•å±‚ç½‘ç»œåº“ CFNetwork åˆ™æ²¡æœ‰è¿™ä¸ªé™åˆ¶ã€‚

å¯¹äº NSURLProtocol çš„å…·ä½“åšæ³•åœ¨[è¿™ç¯‡æ–‡ç« ](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1 - iOS/1.83.md)ä¸­è®²è¿‡ï¼Œç»§æ‰¿æŠ½è±¡ç±»å¹¶å®ç°ç›¸åº”çš„æ–¹æ³•ï¼Œè‡ªå®šä¹‰å»å‘èµ·ç½‘ç»œè¯·æ±‚æ¥å®ç°ç›‘æ§çš„ç›®çš„ã€‚

iOS 10 ä¹‹åï¼ŒNSURLSessionTaskDelegate ä¸­å¢åŠ äº†ä¸€ä¸ªæ–°çš„ä»£ç†æ–¹æ³•ï¼š

```
/*
 * Sent when complete statistics information has been collected for the task.
 */
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));
```

å¯ä»¥ä» `NSURLSessionTaskMetrics` ä¸­è·å–åˆ°ç½‘ç»œæƒ…å†µçš„å„é¡¹æŒ‡æ ‡ã€‚å„é¡¹å‚æ•°å¦‚ä¸‹

```
@interface NSURLSessionTaskMetrics : NSObject

/*
 * transactionMetrics array contains the metrics collected for every request/response transaction created during the task execution.
 */
@property (copy, readonly) NSArray<NSURLSessionTaskTransactionMetrics *> *transactionMetrics;

/*
 * Interval from the task creation time to the task completion time.
 * Task creation time is the time when the task was instantiated.
 * Task completion time is the time when the task is about to change its internal state to completed.
 */
@property (copy, readonly) NSDateInterval *taskInterval;

/*
 * redirectCount is the number of redirects that were recorded.
 */
@property (assign, readonly) NSUInteger redirectCount;

- (instancetype)init API_DEPRECATED("Not supported", macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));
+ (instancetype)new API_DEPRECATED("Not supported", macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));

@end
```

å…¶ä¸­ï¼š`taskInterval` è¡¨ç¤ºä»»åŠ¡ä»åˆ›å»ºåˆ°å®Œæˆè¯è´¹çš„æ€»æ—¶é—´ï¼Œä»»åŠ¡çš„åˆ›å»ºæ—¶é—´æ˜¯ä»»åŠ¡è¢«å®ä¾‹åŒ–æ—¶çš„æ—¶é—´ï¼Œä»»åŠ¡å®Œæˆæ—¶é—´æ˜¯ä»»åŠ¡çš„å†…éƒ¨çŠ¶æ€å°†è¦å˜ä¸ºå®Œæˆçš„æ—¶é—´ï¼›`redirectCount` è¡¨ç¤ºè¢«é‡å®šå‘çš„æ¬¡æ•°ï¼›`transactionMetrics` æ•°ç»„åŒ…å«äº†ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­æ¯ä¸ªè¯·æ±‚/å“åº”äº‹åŠ¡ä¸­æ”¶é›†çš„æŒ‡æ ‡ï¼Œå„é¡¹å‚æ•°å¦‚ä¸‹ï¼š

```
/*
 * This class defines the performance metrics collected for a request/response transaction during the task execution.
 */
API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0))
@interface NSURLSessionTaskTransactionMetrics : NSObject

/*
 * Represents the transaction request. è¯·æ±‚äº‹åŠ¡
 */
@property (copy, readonly) NSURLRequest *request;

/*
 * Represents the transaction response. Can be nil if error occurred and no response was generated. å“åº”äº‹åŠ¡
 */
@property (nullable, copy, readonly) NSURLResponse *response;

/*
 * For all NSDate metrics below, if that aspect of the task could not be completed, then the corresponding â€œEndDateâ€ metric will be nil.
 * For example, if a name lookup was started but the name lookup timed out, failed, or the client canceled the task before the name could be resolved -- then while domainLookupStartDate may be set, domainLookupEndDate will be nil along with all later metrics.
 */

/*
 * å®¢æˆ·ç«¯å¼€å§‹è¯·æ±‚çš„æ—¶é—´ï¼Œæ— è®ºæ˜¯ä»æœåŠ¡å™¨è¿˜æ˜¯ä»æœ¬åœ°ç¼“å­˜ä¸­è·å–
 * fetchStartDate returns the time when the user agent started fetching the resource, whether or not the resource was retrieved from the server or local resources.
 *
 * The following metrics will be set to nil, if a persistent connection was used or the resource was retrieved from local resources:
 *
 *   domainLookupStartDate
 *   domainLookupEndDate
 *   connectStartDate
 *   connectEndDate
 *   secureConnectionStartDate
 *   secureConnectionEndDate
 */
@property (nullable, copy, readonly) NSDate *fetchStartDate;

/*
 * domainLookupStartDate returns the time immediately before the user agent started the name lookup for the resource. DNS å¼€å§‹è§£æçš„æ—¶é—´
 */
@property (nullable, copy, readonly) NSDate *domainLookupStartDate;

/*
 * domainLookupEndDate returns the time after the name lookup was completed. DNS è§£æå®Œæˆçš„æ—¶é—´
 */
@property (nullable, copy, readonly) NSDate *domainLookupEndDate;

/*
 * connectStartDate is the time immediately before the user agent started establishing the connection to the server.
 *
 * For example, this would correspond to the time immediately before the user agent started trying to establish the TCP connection. å®¢æˆ·ç«¯ä¸æœåŠ¡ç«¯å¼€å§‹å»ºç«‹ TCP è¿æ¥çš„æ—¶é—´
 */
@property (nullable, copy, readonly) NSDate *connectStartDate;

/*
 * If an encrypted connection was used, secureConnectionStartDate is the time immediately before the user agent started the security handshake to secure the current connection. HTTPS çš„ TLS æ¡æ‰‹å¼€å§‹çš„æ—¶é—´
 *
 * For example, this would correspond to the time immediately before the user agent started the TLS handshake. 
 *
 * If an encrypted connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSDate *secureConnectionStartDate;

/*
 * If an encrypted connection was used, secureConnectionEndDate is the time immediately after the security handshake completed. HTTPS çš„ TLS æ¡æ‰‹ç»“æŸçš„æ—¶é—´
 *
 * If an encrypted connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSDate *secureConnectionEndDate;

/*
 * connectEndDate is the time immediately after the user agent finished establishing the connection to the server, including completion of security-related and other handshakes. å®¢æˆ·ç«¯ä¸æœåŠ¡å™¨å»ºç«‹ TCP è¿æ¥å®Œæˆçš„æ—¶é—´ï¼ŒåŒ…æ‹¬ TLS æ¡æ‰‹æ—¶é—´
 */
@property (nullable, copy, readonly) NSDate *connectEndDate;

/*
 * requestStartDate is the time immediately before the user agent started requesting the source, regardless of whether the resource was retrieved from the server or local resources.
 å®¢æˆ·ç«¯è¯·æ±‚å¼€å§‹çš„æ—¶é—´ï¼Œå¯ä»¥ç†è§£ä¸ºå¼€å§‹ä¼ è¾“ HTTP è¯·æ±‚çš„ header çš„ç¬¬ä¸€ä¸ªå­—èŠ‚æ—¶é—´
 *
 * For example, this would correspond to the time immediately before the user agent sent an HTTP GET request.
 */
@property (nullable, copy, readonly) NSDate *requestStartDate;

/*
 * requestEndDate is the time immediately after the user agent finished requesting the source, regardless of whether the resource was retrieved from the server or local resources.
 å®¢æˆ·ç«¯è¯·æ±‚ç»“æŸçš„æ—¶é—´ï¼Œå¯ä»¥ç†è§£ä¸º HTTP è¯·æ±‚çš„æœ€åä¸€ä¸ªå­—èŠ‚ä¼ è¾“å®Œæˆçš„æ—¶é—´
 *
 * For example, this would correspond to the time immediately after the user agent finished sending the last byte of the request.
 */
@property (nullable, copy, readonly) NSDate *requestEndDate;

/*
 * responseStartDate is the time immediately after the user agent received the first byte of the response from the server or from local resources.
 å®¢æˆ·ç«¯ä»æœåŠ¡ç«¯æ¥æ”¶å“åº”çš„ç¬¬ä¸€ä¸ªå­—èŠ‚çš„æ—¶é—´
 *
 * For example, this would correspond to the time immediately after the user agent received the first byte of an HTTP response.
 */
@property (nullable, copy, readonly) NSDate *responseStartDate;

/*
 * responseEndDate is the time immediately after the user agent received the last byte of the resource. å®¢æˆ·ç«¯ä»æœåŠ¡ç«¯æ¥æ”¶åˆ°æœ€åä¸€ä¸ªè¯·æ±‚çš„æ—¶é—´
 */
@property (nullable, copy, readonly) NSDate *responseEndDate;

/*
 * The network protocol used to fetch the resource, as identified by the ALPN Protocol ID Identification Sequence [RFC7301].
 * E.g., h2, http/1.1, spdy/3.1.
 ç½‘ç»œåè®®åï¼Œæ¯”å¦‚ http/1.1, spdy/3.1
 *
 * When a proxy is configured AND a tunnel connection is established, then this attribute returns the value for the tunneled protocol.
 *
 * For example:
 * If no proxy were used, and HTTP/2 was negotiated, then h2 would be returned.
 * If HTTP/1.1 were used to the proxy, and the tunneled connection was HTTP/2, then h2 would be returned.
 * If HTTP/1.1 were used to the proxy, and there were no tunnel, then http/1.1 would be returned.
 *
 */
@property (nullable, copy, readonly) NSString *networkProtocolName;

/*
 * This property is set to YES if a proxy connection was used to fetch the resource.
	è¯¥è¿æ¥æ˜¯å¦ä½¿ç”¨äº†ä»£ç†
 */
@property (assign, readonly, getter=isProxyConnection) BOOL proxyConnection;

/*
 * This property is set to YES if a persistent connection was used to fetch the resource.
 æ˜¯å¦å¤ç”¨äº†ç°æœ‰è¿æ¥
 */
@property (assign, readonly, getter=isReusedConnection) BOOL reusedConnection;

/*
 * Indicates whether the resource was loaded, pushed or retrieved from the local cache.
 è·å–èµ„æºæ¥æº
 */
@property (assign, readonly) NSURLSessionTaskMetricsResourceFetchType resourceFetchType;

/*
 * countOfRequestHeaderBytesSent is the number of bytes transferred for request header.
 è¯·æ±‚å¤´çš„å­—èŠ‚æ•°
 */
@property (readonly) int64_t countOfRequestHeaderBytesSent API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfRequestBodyBytesSent is the number of bytes transferred for request body.
 è¯·æ±‚ä½“çš„å­—èŠ‚æ•°
 * It includes protocol-specific framing, transfer encoding, and content encoding.
 */
@property (readonly) int64_t countOfRequestBodyBytesSent API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfRequestBodyBytesBeforeEncoding is the size of upload body data, file, or stream.
 ä¸Šä¼ ä½“æ•°æ®ã€æ–‡ä»¶ã€æµçš„å¤§å°
 */
@property (readonly) int64_t countOfRequestBodyBytesBeforeEncoding API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfResponseHeaderBytesReceived is the number of bytes transferred for response header.
 å“åº”å¤´çš„å­—èŠ‚æ•°
 */
@property (readonly) int64_t countOfResponseHeaderBytesReceived API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfResponseBodyBytesReceived is the number of bytes transferred for response body.
 å“åº”ä½“çš„å­—èŠ‚æ•°
 * It includes protocol-specific framing, transfer encoding, and content encoding.
 */
@property (readonly) int64_t countOfResponseBodyBytesReceived API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * countOfResponseBodyBytesAfterDecoding is the size of data delivered to your delegate or completion handler.
ç»™ä»£ç†æ–¹æ³•æˆ–è€…å®Œæˆåå¤„ç†çš„å›è°ƒçš„æ•°æ®å¤§å°
 
 */
@property (readonly) int64_t countOfResponseBodyBytesAfterDecoding API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * localAddress is the IP address string of the local interface for the connection.
  å½“å‰è¿æ¥ä¸‹çš„æœ¬åœ°æ¥å£ IP åœ°å€
 *
 * For multipath protocols, this is the local address of the initial flow.
 *
 * If a connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSString *localAddress API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * localPort is the port number of the local interface for the connection.
 å½“å‰è¿æ¥ä¸‹çš„æœ¬åœ°ç«¯å£å·
 
 *
 * For multipath protocols, this is the local port of the initial flow.
 *
 * If a connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSNumber *localPort API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * remoteAddress is the IP address string of the remote interface for the connection.
 å½“å‰è¿æ¥ä¸‹çš„è¿œç«¯ IP åœ°å€
 *
 * For multipath protocols, this is the remote address of the initial flow.
 *
 * If a connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSString *remoteAddress API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * remotePort is the port number of the remote interface for the connection.
  å½“å‰è¿æ¥ä¸‹çš„è¿œç«¯ç«¯å£å·
 *
 * For multipath protocols, this is the remote port of the initial flow.
 *
 * If a connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSNumber *remotePort API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * negotiatedTLSProtocolVersion is the TLS protocol version negotiated for the connection.
  è¿æ¥åå•†ç”¨çš„ TLS åè®®ç‰ˆæœ¬å·
 * It is a 2-byte sequence in host byte order.
 *
 * Please refer to tls_protocol_version_t enum in Security/SecProtocolTypes.h
 *
 * If an encrypted connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSNumber *negotiatedTLSProtocolVersion API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * negotiatedTLSCipherSuite is the TLS cipher suite negotiated for the connection.
 è¿æ¥åå•†ç”¨çš„ TLS å¯†ç å¥—ä»¶
 * It is a 2-byte sequence in host byte order.
 *
 * Please refer to tls_ciphersuite_t enum in Security/SecProtocolTypes.h
 *
 * If an encrypted connection was not used, this attribute is set to nil.
 */
@property (nullable, copy, readonly) NSNumber *negotiatedTLSCipherSuite API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * Whether the connection is established over a cellular interface.
 æ˜¯å¦æ˜¯é€šè¿‡èœ‚çªç½‘ç»œå»ºç«‹çš„è¿æ¥
 */
@property (readonly, getter=isCellular) BOOL cellular API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * Whether the connection is established over an expensive interface.
 æ˜¯å¦é€šè¿‡æ˜‚è´µçš„æ¥å£å»ºç«‹çš„è¿æ¥
 */
@property (readonly, getter=isExpensive) BOOL expensive API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * Whether the connection is established over a constrained interface.
 æ˜¯å¦é€šè¿‡å—é™æ¥å£å»ºç«‹çš„è¿æ¥
 */
@property (readonly, getter=isConstrained) BOOL constrained API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));

/*
 * Whether a multipath protocol is successfully negotiated for the connection.
 æ˜¯å¦ä¸ºäº†è¿æ¥æˆåŠŸåå•†äº†å¤šè·¯å¾„åè®®
 */
@property (readonly, getter=isMultipath) BOOL multipath API_AVAILABLE(macos(10.15), ios(13.0), watchos(6.0), tvos(13.0));


- (instancetype)init API_DEPRECATED("Not supported", macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));
+ (instancetype)new API_DEPRECATED("Not supported", macos(10.12,10.15), ios(10.0,13.0), watchos(3.0,6.0), tvos(10.0,13.0));

@end
```

**ç½‘ç»œç›‘æ§ç®€å•ä»£ç **

```
// ç›‘æ§åŸºç¡€ä¿¡æ¯
@interface  NetworkMonitorBaseDataModel : NSObject
// è¯·æ±‚çš„ URL åœ°å€
@property (nonatomic, strong) NSString *requestUrl;
//è¯·æ±‚å¤´
@property (nonatomic, strong) NSArray *requestHeaders;
//å“åº”å¤´
@property (nonatomic, strong) NSArray *responseHeaders;
//GETæ–¹æ³• çš„è¯·æ±‚å‚æ•°
@property (nonatomic, strong) NSString *getRequestParams;
//HTTP æ–¹æ³•, æ¯”å¦‚ POST
@property (nonatomic, strong) NSString *httpMethod;
//åè®®åï¼Œå¦‚http1.0 / http1.1 / http2.0
@property (nonatomic, strong) NSString *httpProtocol;
//æ˜¯å¦ä½¿ç”¨ä»£ç†
@property (nonatomic, assign) BOOL useProxy;
//DNSè§£æåçš„ IP åœ°å€
@property (nonatomic, strong) NSString *ip;
@end

// ç›‘æ§ä¿¡æ¯æ¨¡å‹
@interface  NetworkMonitorDataModel : NetworkMonitorBaseDataModel
//å®¢æˆ·ç«¯å‘èµ·è¯·æ±‚çš„æ—¶é—´
@property (nonatomic, assign) UInt64 requestDate;
//å®¢æˆ·ç«¯å¼€å§‹è¯·æ±‚åˆ°å¼€å§‹dnsè§£æçš„ç­‰å¾…æ—¶é—´,å•ä½ms 
@property (nonatomic, assign) int waitDNSTime;
//DNS è§£æè€—æ—¶
@property (nonatomic, assign) int dnsLookupTime;
//tcp ä¸‰æ¬¡æ¡æ‰‹è€—æ—¶,å•ä½ms
@property (nonatomic, assign) int tcpTime;
//ssl æ¡æ‰‹è€—æ—¶
@property (nonatomic, assign) int sslTime;
//ä¸€ä¸ªå®Œæ•´è¯·æ±‚çš„è€—æ—¶,å•ä½ms
@property (nonatomic, assign) int requestTime;
//http å“åº”ç 
@property (nonatomic, assign) NSUInteger httpCode;
//å‘é€çš„å­—èŠ‚æ•°
@property (nonatomic, assign) UInt64 sendBytes;
//æ¥æ”¶çš„å­—èŠ‚æ•°
@property (nonatomic, assign) UInt64 receiveBytes;


// é”™è¯¯ä¿¡æ¯æ¨¡å‹
@interface  NetworkMonitorErrorModel : NetworkMonitorBaseDataModel
//é”™è¯¯ç 
@property (nonatomic, assign) NSInteger errorCode;
//é”™è¯¯æ¬¡æ•°
@property (nonatomic, assign) NSUInteger errCount;
//å¼‚å¸¸å
@property (nonatomic, strong) NSString *exceptionName;
//å¼‚å¸¸è¯¦æƒ…
@property (nonatomic, strong) NSString *exceptionDetail;
//å¼‚å¸¸å †æ ˆ
@property (nonatomic, strong) NSString *stackTrace;
@end

  
// ç»§æ‰¿è‡ª NSURLProtocol æŠ½è±¡ç±»ï¼Œå®ç°å“åº”æ–¹æ³•ï¼Œä»£ç†ç½‘ç»œè¯·æ±‚
@interface CustomURLProtocol () <NSURLSessionTaskDelegate>

@property (nonatomic, strong) NSURLSessionDataTask *dataTask;
@property (nonatomic, strong) NSOperationQueue *sessionDelegateQueue;
@property (nonatomic, strong) NetworkMonitorDataModel *dataModel;
@property (nonatomic, strong) NetworkMonitorErrorModel *errModel;

@end

//ä½¿ç”¨NSURLSessionDataTaskè¯·æ±‚ç½‘ç»œ
- (void)startLoading {
    NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];
  	NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration
                                                          delegate:self
                                                     delegateQueue:nil];
    NSURLSession *session = [NSURLSession sessionWithConfiguration:configuration delegate:self delegateQueue:nil];
  	self.sessionDelegateQueue = [[NSOperationQueue alloc] init];
    self.sessionDelegateQueue.maxConcurrentOperationCount = 1;
    self.sessionDelegateQueue.name = @"com.networkMonitor.session.queue";
    self.dataTask = [session dataTaskWithRequest:self.request];
    [self.dataTask resume];
}

#pragma mark - NSURLSessionTaskDelegate
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didCompleteWithError:(NSError *)error {
    if (error) {
        [self.client URLProtocol:self didFailWithError:error];
    } else {
        [self.client URLProtocolDidFinishLoading:self];
    }
    if (error) {
        NSURLRequest *request = task.currentRequest;
        if (request) {
            self.errModel.requestUrl  = request.URL.absoluteString;        
            self.errModel.httpMethod = request.HTTPMethod;
            self.errModel.requestParams = request.URL.query;
        }
        self.errModel.errorCode = error.code;
        self.errModel.exceptionName = error.domain;
        self.errModel.exceptionDetail = error.description;
      // ä¸Šä¼  Network æ•°æ®åˆ°æ•°æ®ä¸ŠæŠ¥ç»„ä»¶ï¼Œæ•°æ®ä¸ŠæŠ¥ä¼šåœ¨ [æ‰“é€ åŠŸèƒ½å¼ºå¤§ã€çµæ´»å¯é…ç½®çš„æ•°æ®ä¸ŠæŠ¥ç»„ä»¶](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) è®²
    }
    self.dataTask = nil;
}


- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics {
       if (@available(iOS 10.0, *) && [metrics.transactionMetrics count] > 0) {
        [metrics.transactionMetrics enumerateObjectsUsingBlock:^(NSURLSessionTaskTransactionMetrics *_Nonnull obj, NSUInteger idx, BOOL *_Nonnull stop) {
            if (obj.resourceFetchType == NSURLSessionTaskMetricsResourceFetchTypeNetworkLoad) {
                if (obj.fetchStartDate) {
                    self.dataModel.requestDate = [obj.fetchStartDate timeIntervalSince1970] * 1000;
                }
                if (obj.domainLookupStartDate && obj.domainLookupEndDate) {
                    self.dataModel. waitDNSTime = ceil([obj.domainLookupStartDate timeIntervalSinceDate:obj.fetchStartDate] * 1000);
                    self.dataModel. dnsLookupTime = ceil([obj.domainLookupEndDate timeIntervalSinceDate:obj.domainLookupStartDate] * 1000);
                }
                if (obj.connectStartDate) {
                    if (obj.secureConnectionStartDate) {
                        self.dataModel. waitDNSTime = ceil([obj.secureConnectionStartDate timeIntervalSinceDate:obj.connectStartDate] * 1000);
                    } else if (obj.connectEndDate) {
                        self.dataModel.tcpTime = ceil([obj.connectEndDate timeIntervalSinceDate:obj.connectStartDate] * 1000);
                    }
                }
                if (obj.secureConnectionEndDate && obj.secureConnectionStartDate) {
                    self.dataModel.sslTime = ceil([obj.secureConnectionEndDate timeIntervalSinceDate:obj.secureConnectionStartDate] * 1000);
                }

                if (obj.fetchStartDate && obj.responseEndDate) {
                    self.dataModel.requestTime = ceil([obj.responseEndDate timeIntervalSinceDate:obj.fetchStartDate] * 1000);
                }

                self.dataModel.httpProtocol = obj.networkProtocolName;

                NSHTTPURLResponse *response = (NSHTTPURLResponse *)obj.response;
                if ([response isKindOfClass:NSHTTPURLResponse.class]) {
                    self.dataModel.receiveBytes = response.expectedContentLength;
                }

                if ([obj respondsToSelector:@selector(_remoteAddressAndPort)]) {
                    self.dataModel.ip = [obj valueForKey:@"_remoteAddressAndPort"];
                }

                if ([obj respondsToSelector:@selector(_requestHeaderBytesSent)]) {
                    self.dataModel.sendBytes = [[obj valueForKey:@"_requestHeaderBytesSent"] unsignedIntegerValue];
                }
                if ([obj respondsToSelector:@selector(_responseHeaderBytesReceived)]) {
                    self.dataModel.receiveBytes = [[obj valueForKey:@"_responseHeaderBytesReceived"] unsignedIntegerValue];
                }

               self.dataModel.requestUrl = [obj.request.URL absoluteString];
                self.dataModel.httpMethod = obj.request.HTTPMethod;
                self.dataModel.useProxy = obj.isProxyConnection;
            }
        }];
				// ä¸Šä¼  Network æ•°æ®åˆ°æ•°æ®ä¸ŠæŠ¥ç»„ä»¶ï¼Œæ•°æ®ä¸ŠæŠ¥ä¼šåœ¨ [æ‰“é€ åŠŸèƒ½å¼ºå¤§ã€çµæ´»å¯é…ç½®çš„æ•°æ®ä¸ŠæŠ¥ç»„ä»¶](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1%20-%20iOS/1.80.md) è®²
    }
}
```

#### 2.2 æ–¹æ¡ˆäºŒï¼šNSURLProtocol ç›‘æ§ App ç½‘ç»œè¯·æ±‚ä¹‹é»‘é­”æ³•ç¯‡

æ–‡ç« ä¸Šé¢ [2.1 ](http://www.gsnice.com/2020/07/å¸¦ä½ æ‰“é€ ä¸€å¥—-APM-ç›‘æ§ç³»ç»Ÿ-ä¸‰/#network-2.1)åˆ†æåˆ°äº† NSURLSessionTaskMetrics ç”±äºå…¼å®¹æ€§é—®é¢˜ï¼Œå¯¹äºç½‘ç»œç›‘æ§æ¥è¯´ä¼¼ä¹ä¸å¤ªå®Œç¾ï¼Œä½†æ˜¯è‡ªååœ¨æœèµ„æ–™çš„æ—¶å€™çœ‹åˆ°äº†ä¸€ç¯‡[æ–‡ç« ](https://www.jianshu.com/p/1c34147030d1)ã€‚æ–‡ç« åœ¨åˆ†æ WebView çš„ç½‘ç»œç›‘æ§çš„æ—¶å€™åˆ†æ Webkit æºç çš„æ—¶å€™å‘ç°äº†ä¸‹é¢ä»£ç 

```
#if !HAVE(TIMINGDATAOPTIONS)
void setCollectsTimingData()
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        [NSURLConnection _setCollectsTimingData:YES];
        ...
    });
}
#endif
```

ä¹Ÿå°±æ˜¯è¯´æ˜ NSURLConnection æœ¬èº«æœ‰ä¸€å¥— `TimingData` çš„æ”¶é›† APIï¼Œåªæ˜¯æ²¡æœ‰æš´éœ²ç»™å¼€å‘è€…ï¼Œè‹¹æœè‡ªå·±åœ¨ç”¨è€Œå·²ã€‚åœ¨ runtime header ä¸­æ‰¾åˆ°äº† NSURLConnection çš„ `_setCollectsTimingData:` ã€`_timingData` 2ä¸ª apiï¼ˆiOS8 ä»¥åå¯ä»¥ä½¿ç”¨ï¼‰ã€‚

NSURLSession åœ¨ iOS9 ä¹‹å‰ä½¿ç”¨ `_setCollectsTimingData:` å°±å¯ä»¥ä½¿ç”¨ TimingData äº†ã€‚

æ³¨æ„ï¼š

- å› ä¸ºæ˜¯ç§æœ‰ APIï¼Œæ‰€ä»¥åœ¨ä½¿ç”¨çš„æ—¶å€™æ³¨æ„æ··æ·†ã€‚æ¯”å¦‚ `[[@"_setC" stringByAppendingString:@"ollectsT"] stringByAppendingString:@"imingData:"]`ã€‚
- ä¸æ¨èç§æœ‰ APIï¼Œä¸€èˆ¬åš APM çš„å±äºå…¬å…±å›¢é˜Ÿï¼Œä½ æƒ³æƒ³çœ‹è™½ç„¶ä½ åšçš„ SDK è¾¾åˆ°ç½‘ç»œç›‘æ§çš„ç›®çš„äº†ï¼Œä½†æ˜¯ä¸‡ä¸€ç»™ä¸šåŠ¡çº¿çš„ App ä¸Šæ¶é€ æˆäº†é—®é¢˜ï¼Œé‚£å°±å¾—ä¸å¿å¤±äº†ã€‚ä¸€èˆ¬è¿™ç§æŠ•æœºå–å·§ï¼Œä¸æ˜¯ç™¾åˆ†ç™¾ç¡®å®šçš„äº‹æƒ…å¯ä»¥åœ¨ç©å…·é˜¶æ®µä½¿ç”¨ã€‚

```
@interface _NSURLConnectionProxy : DelegateProxy

@end

@implementation _NSURLConnectionProxy

- (BOOL)respondsToSelector:(SEL)aSelector
{
    if ([NSStringFromSelector(aSelector) isEqualToString:@"connectionDidFinishLoading:"]) {
        return YES;
    }
    return [self.target respondsToSelector:aSelector];
}

- (void)forwardInvocation:(NSInvocation *)invocation
{
    [super forwardInvocation:invocation];
    if ([NSStringFromSelector(invocation.selector) isEqualToString:@"connectionDidFinishLoading:"]) {
        __unsafe_unretained NSURLConnection *conn;
        [invocation getArgument:&conn atIndex:2];
        SEL selector = NSSelectorFromString([@"_timin" stringByAppendingString:@"gData"]);
        NSDictionary *timingData = [conn performSelector:selector];
        [[NTDataKeeper shareInstance] trackTimingData:timingData request:conn.currentRequest];
    }
}

@end

@implementation NSURLConnection(tracker)

+ (void)load
{
    static dispatch_once_t onceToken;
    dispatch_once(&onceToken, ^{
        Class class = [self class];
        
        SEL originalSelector = @selector(initWithRequest:delegate:);
        SEL swizzledSelector = @selector(swizzledInitWithRequest:delegate:);
        
        Method originalMethod = class_getInstanceMethod(class, originalSelector);
        Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector);
        method_exchangeImplementations(originalMethod, swizzledMethod);
        
        NSString *selectorName = [[@"_setC" stringByAppendingString:@"ollectsT"] stringByAppendingString:@"imingData:"];
        SEL selector = NSSelectorFromString(selectorName);
        [NSURLConnection performSelector:selector withObject:@(YES)];
    });
}

- (instancetype)swizzledInitWithRequest:(NSURLRequest *)request delegate:(id<NSURLConnectionDelegate>)delegate
{
    if (delegate) {
        _NSURLConnectionProxy *proxy = [[_NSURLConnectionProxy alloc] initWithTarget:delegate];
        objc_setAssociatedObject(delegate ,@"_NSURLConnectionProxy" ,proxy, OBJC_ASSOCIATION_RETAIN_NONATOMIC);
        return [self swizzledInitWithRequest:request delegate:(id<NSURLConnectionDelegate>)proxy];
    }else{
        return [self swizzledInitWithRequest:request delegate:delegate];
    }
}

@end
```

#### 2.3 æ–¹æ¡ˆä¸‰ï¼šHook

iOS ä¸­ hook æŠ€æœ¯æœ‰2ç±»ï¼Œä¸€ç§æ˜¯ NSProxyï¼Œä¸€ç§æ˜¯ method swizzlingï¼ˆisa swizzlingï¼‰

##### 2.3.1 æ–¹æ³•ä¸€

å†™ SDK è‚¯å®šä¸å¯èƒ½æ‰‹åŠ¨ä¾µå…¥ä¸šåŠ¡ä»£ç ï¼ˆä½ æ²¡é‚£ä¸ªæƒé™æäº¤åˆ°çº¿ä¸Šä»£ç  ğŸ˜‚ï¼‰ï¼Œæ‰€ä»¥ä¸ç®¡æ˜¯ APM è¿˜æ˜¯æ— ç—•åŸ‹ç‚¹éƒ½æ˜¯é€šè¿‡ Hook çš„æ–¹å¼ã€‚

é¢å‘åˆ‡é¢ç¨‹åºè®¾è®¡ï¼ˆAspect-oriented Programmingï¼ŒAOPï¼‰æ˜¯è®¡ç®—æœºç§‘å­¦ä¸­çš„ä¸€ç§ç¨‹åºè®¾è®¡èŒƒå‹ï¼Œå°†**æ¨ªåˆ‡å…³æ³¨ç‚¹**ä¸ä¸šåŠ¡ä¸»ä½“è¿›ä¸€æ­¥åˆ†ç¦»ï¼Œä»¥æé«˜ç¨‹åºä»£ç çš„æ¨¡å—åŒ–ç¨‹åº¦ã€‚åœ¨ä¸ä¿®æ”¹æºä»£ç çš„æƒ…å†µä¸‹ç»™ç¨‹åºåŠ¨æ€å¢åŠ åŠŸèƒ½ã€‚å…¶æ ¸å¿ƒæ€æƒ³æ˜¯å°†ä¸šåŠ¡é€»è¾‘ï¼ˆæ ¸å¿ƒå…³æ³¨ç‚¹ï¼Œç³»ç»Ÿä¸»è¦åŠŸèƒ½ï¼‰ä¸å…¬å…±åŠŸèƒ½ï¼ˆæ¨ªåˆ‡å…³æ³¨ç‚¹ï¼Œæ¯”å¦‚æ—¥å¿—ç³»ç»Ÿï¼‰è¿›è¡Œåˆ†ç¦»ï¼Œé™ä½å¤æ‚æ€§ï¼Œä¿æŒç³»ç»Ÿæ¨¡å—åŒ–ç¨‹åº¦ã€å¯ç»´æŠ¤æ€§ã€å¯é‡ç”¨æ€§ã€‚å¸¸è¢«ç”¨åœ¨æ—¥å¿—ç³»ç»Ÿã€æ€§èƒ½ç»Ÿè®¡ã€å®‰å…¨æ§åˆ¶ã€äº‹åŠ¡å¤„ç†ã€å¼‚å¸¸å¤„ç†ç­‰åœºæ™¯ä¸‹ã€‚

åœ¨ iOS ä¸­ AOP çš„å®ç°æ˜¯åŸºäº Runtime æœºåˆ¶ï¼Œç›®å‰ç”±3ç§æ–¹å¼ï¼šMethod Swizzlingã€NSProxyã€FishHookï¼ˆä¸»è¦ç”¨ç”¨äº hook c ä»£ç ï¼‰ã€‚

æ–‡ç« ä¸Šé¢ [2.1 ](http://www.gsnice.com/2020/07/å¸¦ä½ æ‰“é€ ä¸€å¥—-APM-ç›‘æ§ç³»ç»Ÿ-ä¸‰/#network-2.1)è®¨è®ºäº†æ»¡è¶³å¤§å¤šæ•°çš„éœ€æ±‚çš„åœºæ™¯ï¼ŒNSURLProtocol ç›‘æ§äº† NSURLConnectionã€NSURLSession çš„ç½‘ç»œè¯·æ±‚ï¼Œè‡ªèº«ä»£ç†åå¯ä»¥å‘èµ·ç½‘ç»œè¯·æ±‚å¹¶å¾—åˆ°è¯¸å¦‚è¯·æ±‚å¼€å§‹æ—¶é—´ã€è¯·æ±‚ç»“æŸæ—¶é—´ã€header ä¿¡æ¯ç­‰ï¼Œä½†æ˜¯æ— æ³•å¾—åˆ°éå¸¸è¯¦ç»†çš„ç½‘ç»œæ€§èƒ½æ•°æ®ï¼Œæ¯”å¦‚ DNS å¼€å§‹è§£ææ—¶é—´ã€DNS è§£æç”¨äº†å¤šä¹…ã€reponse å¼€å§‹è¿”å›çš„æ—¶é—´ã€è¿”å›äº†å¤šä¹…ç­‰ã€‚ iOS10 ä¹‹å NSURLSessionTaskDelegate å¢åŠ äº†ä¸€ä¸ªä»£ç†æ–¹æ³• `- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task didFinishCollectingMetrics:(NSURLSessionTaskMetrics *)metrics API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));`ï¼Œå¯ä»¥è·å–åˆ°ç²¾ç¡®çš„å„é¡¹ç½‘ç»œæ•°æ®ã€‚ä½†æ˜¯å…·æœ‰å…¼å®¹æ€§ã€‚æ–‡ç« ä¸Šé¢ [2.2 ](http://www.gsnice.com/2020/07/å¸¦ä½ æ‰“é€ ä¸€å¥—-APM-ç›‘æ§ç³»ç»Ÿ-ä¸‰/#network-2.2)è®¨è®ºäº†ä» Webkit æºç ä¸­å¾—åˆ°çš„ä¿¡æ¯ï¼Œé€šè¿‡ç§æœ‰æ–¹æ³• `_setCollectsTimingData:` ã€`_timingData` å¯ä»¥è·å–åˆ° TimingDataã€‚

ä½†æ˜¯å¦‚æœéœ€è¦ç›‘å…¨éƒ¨çš„ç½‘ç»œè¯·æ±‚å°±ä¸èƒ½æ»¡è¶³éœ€æ±‚äº†ï¼ŒæŸ¥é˜…èµ„æ–™åå‘ç°äº†é˜¿é‡Œç™¾å·æœ‰ APM çš„è§£å†³æ–¹æ¡ˆï¼Œäºæ˜¯æœ‰äº†æ–¹æ¡ˆ3ï¼Œå¯¹äºç½‘ç»œç›‘æ§éœ€è¦åšå¦‚ä¸‹çš„å¤„ç†

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094556259.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

å¯èƒ½å¯¹äº CFNetwork æ¯”è¾ƒé™Œç”Ÿï¼Œå¯ä»¥çœ‹ä¸€ä¸‹ CFNetwork çš„å±‚çº§å’Œç®€å•ç”¨æ³•

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094621799.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

CFNetwork çš„åŸºç¡€æ˜¯ CFSocket å’Œ CFStreamã€‚

CFSocketï¼šSocket æ˜¯ç½‘ç»œé€šä¿¡çš„åº•å±‚åŸºç¡€ï¼Œå¯ä»¥è®©2ä¸ª socket ç«¯å£äº’å‘æ•°æ®ï¼ŒiOS ä¸­æœ€å¸¸ç”¨çš„ socket æŠ½è±¡æ˜¯ BSD socketã€‚è€Œ CFSocket æ˜¯ BSD socket çš„ OC åŒ…è£…ï¼Œå‡ ä¹å®ç°äº†æ‰€æœ‰çš„ BSD åŠŸèƒ½ï¼Œæ­¤å¤–åŠ å…¥äº† RunLoopã€‚

CFStreamï¼šæä¾›äº†ä¸è®¾å¤‡æ— å…³çš„è¯»å†™æ•°æ®æ–¹æ³•ï¼Œä½¿ç”¨å®ƒå¯ä»¥ä¸ºå†…å­˜ã€æ–‡ä»¶ã€ç½‘ç»œï¼ˆä½¿ç”¨ socketï¼‰çš„æ•°æ®å»ºç«‹æµï¼Œä½¿ç”¨ stream å¯ä»¥ä¸å¿…å°†æ‰€æœ‰æ•°æ®å†™å…¥åˆ°å†…å­˜ä¸­ã€‚CFStream æä¾› API å¯¹2ç§ CFType å¯¹è±¡æä¾›æŠ½è±¡ï¼šCFReadStreamã€CFWriteStreamã€‚åŒæ—¶ä¹Ÿæ˜¯ CFHTTPã€CFFTP çš„åŸºç¡€ã€‚

**ç®€å• Demo**

```
- (void)testCFNetwork
{
    CFURLRef urlRef = CFURLCreateWithString(kCFAllocatorDefault, CFSTR("https://httpbin.org/get"), NULL);
    CFHTTPMessageRef httpMessageRef = CFHTTPMessageCreateRequest(kCFAllocatorDefault, CFSTR("GET"), urlRef, kCFHTTPVersion1_1);
    CFRelease(urlRef);
    
    CFReadStreamRef readStream = CFReadStreamCreateForHTTPRequest(kCFAllocatorDefault, httpMessageRef);
    CFRelease(httpMessageRef);
    
    CFReadStreamScheduleWithRunLoop(readStream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);
    
    CFOptionFlags eventFlags = (kCFStreamEventHasBytesAvailable | kCFStreamEventErrorOccurred | kCFStreamEventEndEncountered);
    CFStreamClientContext context = {
        0,
        NULL,
        NULL,
        NULL,
       NULL
    } ;
    // Assigns a client to a stream, which receives callbacks when certain events occur.
    CFReadStreamSetClient(readStream, eventFlags, CFNetworkRequestCallback, &context);
    // Opens a stream for reading.
    CFReadStreamOpen(readStream);
}
// callback
void CFNetworkRequestCallback (CFReadStreamRef _Null_unspecified stream, CFStreamEventType type, void * _Null_unspecified clientCallBackInfo) {
    CFMutableDataRef responseBytes = CFDataCreateMutable(kCFAllocatorDefault, 0);
    CFIndex numberOfBytesRead = 0;
    do {
        UInt8 buffer[2014];
        numberOfBytesRead = CFReadStreamRead(stream, buffer, sizeof(buffer));
        if (numberOfBytesRead > 0) {
            CFDataAppendBytes(responseBytes, buffer, numberOfBytesRead);
        }
    } while (numberOfBytesRead > 0);
    
    
    CFHTTPMessageRef response = (CFHTTPMessageRef)CFReadStreamCopyProperty(stream, kCFStreamPropertyHTTPResponseHeader);
    if (responseBytes) {
        if (response) {
            CFHTTPMessageSetBody(response, responseBytes);
        }
        CFRelease(responseBytes);
    }
    
    // close and cleanup
    CFReadStreamClose(stream);
    CFReadStreamUnscheduleFromRunLoop(stream, CFRunLoopGetCurrent(), kCFRunLoopCommonModes);
    CFRelease(stream);
    
    // print response
    if (response) {
        CFDataRef reponseBodyData = CFHTTPMessageCopyBody(response);
        CFRelease(response);
        
        printResponseData(reponseBodyData);
        CFRelease(reponseBodyData);
    }
}

void printResponseData (CFDataRef responseData) {
    CFIndex dataLength = CFDataGetLength(responseData);
    UInt8 *bytes = (UInt8 *)malloc(dataLength);
    CFDataGetBytes(responseData, CFRangeMake(0, CFDataGetLength(responseData)), bytes);
    CFStringRef responseString = CFStringCreateWithBytes(kCFAllocatorDefault, bytes, dataLength, kCFStringEncodingUTF8, TRUE);
    CFShow(responseString);
    CFRelease(responseString);
    free(bytes);
}
// console
{
  "args": {}, 
  "headers": {
    "Host": "httpbin.org", 
    "User-Agent": "Test/1 CFNetwork/1125.2 Darwin/19.3.0", 
    "X-Amzn-Trace-Id": "Root=1-5e8980d0-581f3f44724c7140614c2564"
  }, 
  "origin": "183.159.122.102", 
  "url": "https://httpbin.org/get"
}
```

æˆ‘ä»¬çŸ¥é“ NSURLSessionã€NSURLConnectionã€CFNetwork çš„ä½¿ç”¨éƒ½éœ€è¦è°ƒç”¨ä¸€å †æ–¹æ³•è¿›è¡Œè®¾ç½®ç„¶åéœ€è¦è®¾ç½®ä»£ç†å¯¹è±¡ï¼Œå®ç°ä»£ç†æ–¹æ³•ã€‚æ‰€ä»¥é’ˆå¯¹è¿™ç§æƒ…å†µè¿›è¡Œç›‘æ§é¦–å…ˆæƒ³åˆ°çš„æ˜¯ä½¿ç”¨ runtime hook æ‰æ–¹æ³•å±‚çº§ã€‚ä½†æ˜¯é’ˆå¯¹è®¾ç½®çš„ä»£ç†å¯¹è±¡çš„ä»£ç†æ–¹æ³•æ²¡åŠæ³• hookï¼Œå› ä¸ºä¸çŸ¥é“ä»£ç†å¯¹è±¡æ˜¯å“ªä¸ªç±»ã€‚æ‰€ä»¥æƒ³åŠæ³•å¯ä»¥ hook è®¾ç½®ä»£ç†å¯¹è±¡è¿™ä¸ªæ­¥éª¤ï¼Œå°†ä»£ç†å¯¹è±¡æ›¿æ¢æˆæˆ‘ä»¬è®¾è®¡å¥½çš„æŸä¸ªç±»ï¼Œç„¶åè®©è¿™ä¸ªç±»å»å®ç° NSURLConnectionã€NSURLSessionã€CFNetwork ç›¸å…³çš„ä»£ç†æ–¹æ³•ã€‚ç„¶ååœ¨è¿™äº›æ–¹æ³•çš„å†…éƒ¨éƒ½å»è°ƒç”¨ä¸€ä¸‹åŸä»£ç†å¯¹è±¡çš„æ–¹æ³•å®ç°ã€‚æ‰€ä»¥æˆ‘ä»¬çš„éœ€æ±‚å¾—ä»¥æ»¡è¶³ï¼Œæˆ‘ä»¬åœ¨ç›¸åº”çš„æ–¹æ³•é‡Œé¢å¯ä»¥æ‹¿åˆ°ç›‘æ§æ•°æ®ï¼Œæ¯”å¦‚è¯·æ±‚å¼€å§‹æ—¶é—´ã€ç»“æŸæ—¶é—´ã€çŠ¶æ€ç ã€å†…å®¹å¤§å°ç­‰ã€‚

NSURLSessionã€NSURLConnection hook å¦‚ä¸‹ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094652174.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094724798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

ä¸šç•Œæœ‰ APM é’ˆå¯¹ CFNetwork çš„æ–¹æ¡ˆï¼Œæ•´ç†æè¿°ä¸‹ï¼š

CFNetwork æ˜¯ c è¯­è¨€å®ç°çš„ï¼Œè¦å¯¹ c ä»£ç è¿›è¡Œ hook éœ€è¦ä½¿ç”¨ Dynamic Loader Hook åº“ - [fishhook](https://github.com/facebook/fishhook)ã€‚

> **Dynamic Loader**ï¼ˆdyldï¼‰é€šè¿‡æ›´æ–° **Mach-O** æ–‡ä»¶ä¸­ä¿å­˜çš„æŒ‡é’ˆçš„æ–¹æ³•æ¥ç»‘å®šç¬¦å·ã€‚å€Ÿç”¨å®ƒå¯ä»¥åœ¨ **Runtime** ä¿®æ”¹ **C** å‡½æ•°è°ƒç”¨çš„å‡½æ•°æŒ‡é’ˆã€‚**fishhook** çš„å®ç°åŸç†ï¼šéå† `__DATA segment` é‡Œé¢ `__nl_symbol_ptr` ã€`__la_symbol_ptr` ä¸¤ä¸ª section é‡Œé¢çš„ç¬¦å·ï¼Œé€šè¿‡ Indirect Symbol Tableã€Symbol Table å’Œ String Table çš„é…åˆï¼Œæ‰¾åˆ°è‡ªå·±è¦æ›¿æ¢çš„å‡½æ•°ï¼Œè¾¾åˆ° hook çš„ç›®çš„ã€‚

> /* Returns the number of bytes read, or -1 if an error occurs preventing any
>
> bytes from being read, or 0 if the streamâ€™s end was encountered.
>
> It is an error to try and read from a stream that hasnâ€™t been opened first.
>
> This call will block until at least one byte is available; it will NOT block
>
> until the entire buffer can be filled. To avoid blocking, either poll using
>
> CFReadStreamHasBytesAvailable() or use the run loop and listen for the
>
> kCFStreamEventHasBytesAvailable event for notification of data available. */
>
> CF_EXPORT
>
> CFIndex CFReadStreamRead(CFReadStreamRef **_Null_unspecified** stream, UInt8 * **_Null_unspecified** buffer, CFIndex bufferLength);

CFNetwork ä½¿ç”¨ CFReadStreamRef æ¥ä¼ é€’æ•°æ®ï¼Œä½¿ç”¨å›è°ƒå‡½æ•°çš„å½¢å¼æ¥æ¥å—æœåŠ¡å™¨çš„å“åº”ã€‚å½“å›è°ƒå‡½æ•°å—åˆ°

å…·ä½“æ­¥éª¤åŠå…¶å…³é”®ä»£ç å¦‚ä¸‹ï¼Œä»¥ NSURLConnection ä¸¾ä¾‹

- å› ä¸ºè¦ Hook æŒºå¤šåœ°æ–¹ï¼Œæ‰€ä»¥å†™ä¸€ä¸ª method swizzling çš„å·¥å…·ç±»

  ```
  #import <Foundation/Foundation.h>
    
  NS_ASSUME_NONNULL_BEGIN
    
  @interface NSObject (hook)
    
  /**
   hookå¯¹è±¡æ–¹æ³•
    
   @param originalSelector éœ€è¦hookçš„åŸå§‹å¯¹è±¡æ–¹æ³•
   @param swizzledSelector éœ€è¦æ›¿æ¢çš„å¯¹è±¡æ–¹æ³•
   */
  + (void)apm_swizzleMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector;
    
  /**
   hookç±»æ–¹æ³•
    
   @param originalSelector éœ€è¦hookçš„åŸå§‹ç±»æ–¹æ³•
   @param swizzledSelector éœ€è¦æ›¿æ¢çš„ç±»æ–¹æ³•
   */
  + (void)apm_swizzleClassMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector;
    
  @end
    
  NS_ASSUME_NONNULL_END
      
  + (void)apm_swizzleMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector
  {
      class_swizzleInstanceMethod(self, originalSelector, swizzledSelector);
  }
    
  + (void)apm_swizzleClassMethod:(SEL)originalSelector swizzledSelector:(SEL)swizzledSelector
  {
      //ç±»æ–¹æ³•å®é™…ä¸Šæ˜¯å‚¨å­˜åœ¨ç±»å¯¹è±¡çš„ç±»(å³å…ƒç±»)ä¸­ï¼Œå³ç±»æ–¹æ³•ç›¸å½“äºå…ƒç±»çš„å®ä¾‹æ–¹æ³•,æ‰€ä»¥åªéœ€è¦æŠŠå…ƒç±»ä¼ å…¥ï¼Œå…¶ä»–é€»è¾‘å’Œäº¤äº’å®ä¾‹æ–¹æ³•ä¸€æ ·ã€‚
      Class class2 = object_getClass(self);
      class_swizzleInstanceMethod(class2, originalSelector, swizzledSelector);
  }
    
  void class_swizzleInstanceMethod(Class class, SEL originalSEL, SEL replacementSEL)
  {
      Method originMethod = class_getInstanceMethod(class, originalSEL);
      Method replaceMethod = class_getInstanceMethod(class, replacementSEL);
        
      if(class_addMethod(class, originalSEL, method_getImplementation(replaceMethod),method_getTypeEncoding(replaceMethod)))
      {
          class_replaceMethod(class,replacementSEL, method_getImplementation(originMethod), method_getTypeEncoding(originMethod));
      }else {
          method_exchangeImplementations(originMethod, replaceMethod);
      }
  }
  ```

- å»ºç«‹ä¸€ä¸ªç»§æ‰¿è‡ª NSProxy æŠ½è±¡ç±»çš„ç±»ï¼Œå®ç°ç›¸åº”æ–¹æ³•ã€‚

  ```
  #import <Foundation/Foundation.h>
    
  NS_ASSUME_NONNULL_BEGIN
    
  // ä¸º NSURLConnectionã€NSURLSessionã€CFNetwork ä»£ç†è®¾ç½®ä»£ç†è½¬å‘
  @interface NetworkDelegateProxy : NSProxy
    
  + (instancetype)setProxyForObject:(id)originalTarget withNewDelegate:(id)newDelegate;
    
  @end
    
  NS_ASSUME_NONNULL_END
      
  // .m
  @interface NetworkDelegateProxy () {
      id _originalTarget;
      id _NewDelegate;
  }
    
  @end
    
  @implementation NetworkDelegateProxy
    
  #pragma mark - life cycle
    
  + (instancetype)sharedInstance {
      static NetworkDelegateProxy *_sharedInstance = nil;
        
      static dispatch_once_t onceToken;
        
      dispatch_once(&onceToken, ^{
          _sharedInstance = [NetworkDelegateProxy alloc];
      });
        
      return _sharedInstance;
  }
    
  #pragma mark - public Method
    
  + (instancetype)setProxyForObject:(id)originalTarget withNewDelegate:(id)newDelegate
  {
      NetworkDelegateProxy *instance = [NetworkDelegateProxy sharedInstance];
      instance->_originalTarget = originalTarget;
      instance->_NewDelegate = newDelegate;
      return instance;
  }
    
  - (void)forwardInvocation:(NSInvocation *)invocation
  {
      if ([_originalTarget respondsToSelector:invocation.selector]) {
          [invocation invokeWithTarget:_originalTarget];
          [((NSURLSessionAndConnectionImplementor *)_NewDelegate) invoke:invocation];
      }
  }
    
  - (nullable NSMethodSignature *)methodSignatureForSelector:(SEL)sel
  {
      return [_originalTarget methodSignatureForSelector:sel];
  }
    
  @end
  ```

- åˆ›å»ºä¸€ä¸ªå¯¹è±¡ï¼Œå®ç° NSURLConnectionã€NSURLSessionã€NSIuputStream ä»£ç†æ–¹æ³•

  ```
  // NetworkImplementor.m
    
  #pragma mark-NSURLConnectionDelegate
  - (void)connection:(NSURLConnection *)connection didFailWithError:(NSError *)error {
      NSLog(@"%s", __func__);
  }
    
  - (nullable NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(nullable NSURLResponse *)response {
      NSLog(@"%s", __func__);
      return request;
  }
    
  #pragma mark-NSURLConnectionDataDelegate
  - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response {
      NSLog(@"%s", __func__);
  }
    
  - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data {
     NSLog(@"%s", __func__);
  }
    
  - (void)connection:(NSURLConnection *)connection   didSendBodyData:(NSInteger)bytesWritten
   totalBytesWritten:(NSInteger)totalBytesWritten
  totalBytesExpectedToWrite:(NSInteger)totalBytesExpectedToWrite {
      NSLog(@"%s", __func__);
  }
    
  - (void)connectionDidFinishLoading:(NSURLConnection *)connection {
      NSLog(@"%s", __func__);
  }
    
  #pragma mark-NSURLConnectionDownloadDelegate
  - (void)connection:(NSURLConnection *)connection didWriteData:(long long)bytesWritten totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes {
      NSLog(@"%s", __func__);
  }
    
  - (void)connectionDidResumeDownloading:(NSURLConnection *)connection totalBytesWritten:(long long)totalBytesWritten expectedTotalBytes:(long long) expectedTotalBytes {
      NSLog(@"%s", __func__);
  }
    
  - (void)connectionDidFinishDownloading:(NSURLConnection *)connection destinationURL:(NSURL *) destinationURL {
      NSLog(@"%s", __func__);
  }
  // æ ¹æ®éœ€æ±‚è‡ªå·±å»å†™éœ€è¦ç›‘æ§çš„æ•°æ®é¡¹
  ```

- ç»™ NSURLConnection æ·»åŠ  Categoryï¼Œä¸“é—¨è®¾ç½® hook ä»£ç†å¯¹è±¡ã€hook NSURLConnection å¯¹è±¡æ–¹æ³•

  ```
  // NSURLConnection+Monitor.m
  @implementation NSURLConnection (Monitor)
    
  + (void)load
  {
      static dispatch_once_t onceToken;
      dispatch_once(&onceToken, ^{
          @autoreleasepool {
              [[self class] apm_swizzleMethod:@selector(apm_initWithRequest:delegate:) swizzledSelector:@selector(initWithRequest: delegate:)];
          }
      });
  }
    
  - (_Nonnull instancetype)apm_initWithRequest:(NSURLRequest *)request delegate:(nullable id)delegate
  {
      /*
       1. åœ¨è®¾ç½® Delegate çš„æ—¶å€™æ›¿æ¢ delegateã€‚
       2. å› ä¸ºè¦åœ¨æ¯ä¸ªä»£ç†æ–¹æ³•é‡Œé¢ï¼Œç›‘æ§æ•°æ®ï¼Œæ‰€ä»¥éœ€è¦å°†ä»£ç†æ–¹æ³•éƒ½ hook ä¸‹
       3. åœ¨åŸä»£ç†æ–¹æ³•æ‰§è¡Œçš„æ—¶å€™ï¼Œè®©æ–°çš„ä»£ç†å¯¹è±¡é‡Œé¢ï¼Œå»æ‰§è¡Œæ–¹æ³•çš„è½¬å‘ï¼Œ
       */
      NSString *traceId = @"traceId";
      NSMutableURLRequest *rq = [request mutableCopy];
      NSString *preTraceId = [request.allHTTPHeaderFields valueForKey:@"head_key_traceid"];
      if (preTraceId) {
          // è°ƒç”¨ hook ä¹‹å‰çš„åˆå§‹åŒ–æ–¹æ³•ï¼Œè¿”å› NSURLConnection
          return [self apm_initWithRequest:rq delegate:delegate];
      } else {
          [rq setValue:traceId forHTTPHeaderField:@"head_key_traceid"];
               
          NSURLSessionAndConnectionImplementor *mockDelegate = [NSURLSessionAndConnectionImplementor new];
          [self registerDelegateMethod:@"connection:didFailWithError:" originalDelegate:delegate newDelegate:mockDelegate flag:"v@:@@"];
    
          [self registerDelegateMethod:@"connection:didReceiveResponse:" originalDelegate:delegate newDelegate:mockDelegate flag:"v@:@@"];
          [self registerDelegateMethod:@"connection:didReceiveData:" originalDelegate:delegate newDelegate:mockDelegate flag:"v@:@@"];
          [self registerDelegateMethod:@"connection:didFailWithError:" originalDelegate:delegate newDelegate:mockDelegate flag:"v@:@@"];
    
          [self registerDelegateMethod:@"connectionDidFinishLoading:" originalDelegate:delegate newDelegate:mockDelegate flag:"v@:@"];
          [self registerDelegateMethod:@"connection:willSendRequest:redirectResponse:" originalDelegate:delegate newDelegate:mockDelegate flag:"@@:@@"];
          delegate = [NetworkDelegateProxy setProxyForObject:delegate withNewDelegate:mockDelegate];
    
          // è°ƒç”¨ hook ä¹‹å‰çš„åˆå§‹åŒ–æ–¹æ³•ï¼Œè¿”å› NSURLConnection
          return [self apm_initWithRequest:rq delegate:delegate];
      }
  }
    
  - (void)registerDelegateMethod:(NSString *)methodName originalDelegate:(id<NSURLConnectionDelegate>)originalDelegate newDelegate:(NSURLSessionAndConnectionImplementor *)newDelegate flag:(const char *)flag
  {
      if ([originalDelegate respondsToSelector:NSSelectorFromString(methodName)]) {
          IMP originalMethodImp = class_getMethodImplementation([originalDelegate class], NSSelectorFromString(methodName));
          IMP newMethodImp = class_getMethodImplementation([newDelegate class], NSSelectorFromString(methodName));
          if (originalMethodImp != newMethodImp) {
              [newDelegate registerSelector: methodName];
              NSLog(@"");
          }
      } else {
          class_addMethod([originalDelegate class], NSSelectorFromString(methodName), class_getMethodImplementation([newDelegate class], NSSelectorFromString(methodName)), flag);
      }
  }
    
  @end
  ```

è¿™æ ·ä¸‹æ¥å°±æ˜¯å¯ä»¥ç›‘æ§åˆ°ç½‘ç»œä¿¡æ¯äº†ï¼Œç„¶åå°†æ•°æ®äº¤ç»™æ•°æ®ä¸ŠæŠ¥ SDKï¼ŒæŒ‰ç…§ä¸‹å‘çš„æ•°æ®ä¸ŠæŠ¥ç­–ç•¥å»ä¸ŠæŠ¥æ•°æ®ã€‚

##### 2.3.2 æ–¹æ³•äºŒ

å…¶å®ï¼Œé’ˆå¯¹ä¸Šè¿°çš„éœ€æ±‚è¿˜æœ‰å¦ä¸€ç§æ–¹æ³•ä¸€æ ·å¯ä»¥è¾¾åˆ°ç›®çš„ï¼Œé‚£å°±æ˜¯ **isa swizzling**ã€‚

é¡ºé“è¯´ä¸€å¥ï¼Œä¸Šé¢é’ˆå¯¹ NSURLConnectionã€NSURLSessionã€NSInputStream ä»£ç†å¯¹è±¡çš„ hook ä¹‹åï¼Œåˆ©ç”¨ NSProxy å®ç°ä»£ç†å¯¹è±¡æ–¹æ³•çš„è½¬å‘ï¼Œæœ‰å¦ä¸€ç§æ–¹æ³•å¯ä»¥å®ç°ï¼Œé‚£å°±æ˜¯ **isa swizzling**ã€‚

- Method swizzling åŸç†

  ```
  struct old_method {
      SEL method_name;
      char *method_types;
      IMP method_imp;
  };
  ```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094757827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

**method swizzling æ”¹è¿›ç‰ˆå¦‚ä¸‹ï¼š**

```
  Method originalMethod = class_getInstanceMethod(aClass, aSEL);
  IMP originalIMP = method_getImplementation(originalMethod);
  char *cd = method_getTypeEncoding(originalMethod);
  IMP newIMP = imp_implementationWithBlock(^(id self) {
    void (*tmp)(id self, SEL _cmd) = originalIMP;
    tmp(self, aSEL);
  });
  class_replaceMethod(aClass, aSEL, newIMP, cd);
```

- isa swizzling

  ```
  /// Represents an instance of a class.
  struct objc_object {
      Class _Nonnull isa  OBJC_ISA_AVAILABILITY;
  };
    
  /// A pointer to an instance of a class.
  typedef struct objc_object *id;
    
  ```

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094826681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

**æˆ‘ä»¬æ¥åˆ†æä¸€ä¸‹ä¸ºä»€ä¹ˆä¿®æ”¹ `isa` å¯ä»¥å®ç°ç›®çš„å‘¢ï¼Ÿ**

1. å†™ APM ç›‘æ§çš„äººæ²¡åŠæ³•ç¡®å®šä¸šåŠ¡ä»£ç 
2. ä¸å¯èƒ½ä¸ºäº†æ–¹ä¾¿ç›‘æ§ APMï¼Œå†™æŸäº›ç±»ï¼Œè®©ä¸šåŠ¡çº¿å¼€å‘è€…åˆ«ä½¿ç”¨ç³»ç»Ÿ NSURLSessionã€NSURLConnection ç±»

**æƒ³æƒ³ KVO çš„å®ç°åŸç†ï¼Ÿç»“åˆä¸Šé¢çš„å›¾ï¼š**

- åˆ›å»ºç›‘æ§å¯¹è±¡å­ç±»
- é‡å†™å­ç±»ä¸­å±æ€§çš„ getterã€seeter
- å°†ç›‘æ§å¯¹è±¡çš„ isa æŒ‡é’ˆæŒ‡å‘æ–°åˆ›å»ºçš„å­ç±»
- åœ¨å­ç±»çš„ getterã€setter ä¸­æ‹¦æˆªå€¼çš„å˜åŒ–ï¼Œé€šçŸ¥ç›‘æ§å¯¹è±¡å€¼çš„å˜åŒ–
- ç›‘æ§å®Œä¹‹åå°†ç›‘æ§å¯¹è±¡çš„ isa è¿˜åŸå›å»

æŒ‰ç…§è¿™ä¸ªæ€è·¯ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å¯¹ NSURLConnectionã€NSURLSession çš„ load æ–¹æ³•ä¸­åŠ¨æ€åˆ›å»ºå­ç±»ï¼Œåœ¨å­ç±»ä¸­é‡å†™æ–¹æ³•ï¼Œæ¯”å¦‚ `- (**nullable** **instancetype**)initWithRequest:(NSURLRequest *)request delegate:(**nullable** **id**)delegate startImmediately:(**BOOL**)startImmediately;` ï¼Œç„¶åå°† NSURLSessionã€NSURLConnection çš„ isa æŒ‡å‘åŠ¨æ€åˆ›å»ºçš„å­ç±»ã€‚åœ¨è¿™äº›æ–¹æ³•å¤„ç†å®Œä¹‹åè¿˜åŸæœ¬èº«çš„ isa æŒ‡é’ˆã€‚

ä¸è¿‡ isa swizzling é’ˆå¯¹çš„è¿˜æ˜¯ method swizzlingï¼Œä»£ç†å¯¹è±¡ä¸ç¡®å®šï¼Œè¿˜æ˜¯éœ€è¦ NSProxy è¿›è¡ŒåŠ¨æ€å¤„ç†ã€‚

**è‡³äºå¦‚ä½•ä¿®æ”¹ isaï¼Œæˆ‘å†™ä¸€ä¸ªç®€å•çš„ Demo æ¥æ¨¡æ‹Ÿ KVOï¼š**

```
- (void)lbpKVO_addObserver:(NSObject *)observer forKeyPath:(NSString *)keyPath options:(NSKeyValueObservingOptions)options context:(nullable void *)context {
    //ç”Ÿæˆè‡ªå®šä¹‰çš„åç§°
    NSString *className = NSStringFromClass(self.class);
    NSString *currentClassName = [@"LBPKVONotifying_" stringByAppendingString:className];
    //1. runtime ç”Ÿæˆç±»
    Class myclass = objc_allocateClassPair(self.class, [currentClassName UTF8String], 0);
    // ç”Ÿæˆåä¸èƒ½é©¬ä¸Šä½¿ç”¨ï¼Œå¿…é¡»å…ˆæ³¨å†Œ
    objc_registerClassPair(myclass);
    
    //2. é‡å†™ setter æ–¹æ³•
    class_addMethod(myclass,@selector(say) , (IMP)say, "v@:@");
    
//    class_addMethod(myclass,@selector(setName:) , (IMP)setName, "v@:@");
    //3. ä¿®æ”¹ isa
    object_setClass(self, myclass);
    
    //4. å°†è§‚å¯Ÿè€…ä¿å­˜åˆ°å½“å‰å¯¹è±¡é‡Œé¢
    objc_setAssociatedObject(self, "observer", observer, OBJC_ASSOCIATION_ASSIGN);
    
    //5. å°†ä¼ é€’çš„ä¸Šä¸‹æ–‡ç»‘å®šåˆ°å½“å‰å¯¹è±¡é‡Œé¢
    objc_setAssociatedObject(self, "context", (__bridge id _Nullable)(context), OBJC_ASSOCIATION_RETAIN);
}

void say(id self, SEL _cmd)
{
   // è°ƒç”¨çˆ¶ç±»æ–¹æ³•ä¸€
    struct objc_super superclass = {self, [self superclass]};
    ((void(*)(struct objc_super *,SEL))objc_msgSendSuper)(&superclass,@selector(say));
    NSLog(@"%s", __func__);
// è°ƒç”¨çˆ¶ç±»æ–¹æ³•äºŒ
//    Class class = [self class];
//    object_setClass(self, class_getSuperclass(class));
//    objc_msgSend(self, @selector(say));
}

void setName (id self, SEL _cmd, NSString *name) {
    NSLog(@"come here");
    //å…ˆåˆ‡æ¢åˆ°å½“å‰ç±»çš„çˆ¶ç±»ï¼Œç„¶åå‘é€æ¶ˆæ¯ setNameï¼Œç„¶ååˆ‡æ¢å½“å‰å­ç±»
    //1. åˆ‡æ¢åˆ°çˆ¶ç±»
    Class class = [self class];
    object_setClass(self, class_getSuperclass(class));
    //2. è°ƒç”¨çˆ¶ç±»çš„ setName æ–¹æ³•
    objc_msgSend(self, @selector(setName:), name);
    
    //3. è°ƒç”¨è§‚å¯Ÿ
    id observer = objc_getAssociatedObject(self, "observer");
    id context = objc_getAssociatedObject(self, "context");
    if (observer) {
        objc_msgSend(observer, @selector(observeValueForKeyPath:ofObject:change:context:), @"name", self, @{@"new": name, @"kind": @1 } , context);
    }
    //4. æ”¹å›å­ç±»
    object_setClass(self, class);
}

@end
```

#### 2.4 æ–¹æ¡ˆå››ï¼šç›‘æ§ App å¸¸è§ç½‘ç»œè¯·æ±‚

æœ¬ç€æˆæœ¬çš„åŸå› ï¼Œç”±äºç°åœ¨å¤§å¤šæ•°çš„é¡¹ç›®çš„ç½‘ç»œèƒ½åŠ›éƒ½æ˜¯é€šè¿‡ [AFNetworking](https://github.com/AFNetworking/AFNetworking) å®Œæˆçš„ï¼Œæ‰€ä»¥æœ¬æ–‡çš„ç½‘ç»œç›‘æ§å¯ä»¥å¿«é€Ÿå®Œæˆã€‚

AFNetworking åœ¨å‘èµ·ç½‘ç»œçš„æ—¶å€™ä¼šæœ‰ç›¸åº”çš„é€šçŸ¥ã€‚`AFNetworkingTaskDidResumeNotification` å’Œ `AFNetworkingTaskDidCompleteNotification`ã€‚é€šè¿‡ç›‘å¬é€šçŸ¥æºå¸¦çš„å‚æ•°è·å–ç½‘ç»œæƒ…å†µä¿¡æ¯ã€‚

```
 self.didResumeObserver = [[NSNotificationCenter defaultCenter] addObserverForName:AFNetworkingTaskDidResumeNotification object:nil queue:self.queue usingBlock:^(NSNotification * _Nonnull note) {
    // å¼€å§‹
    __strong __typeof(weakSelf)strongSelf = weakSelf;
    NSURLSessionTask *task = note.object;
    NSString *requestId = [[NSUUID UUID] UUIDString];
    task.apm_requestId = requestId;
    [strongSelf.networkRecoder recordStartRequestWithRequestID:requestId task:task];
}];

self.didCompleteObserver = [[NSNotificationCenter defaultCenter] addObserverForName:AFNetworkingTaskDidCompleteNotification object:nil queue:self.queue usingBlock:^(NSNotification * _Nonnull note) {
    
    __strong __typeof(weakSelf)strongSelf = weakSelf;
    
    NSError *error = note.userInfo[AFNetworkingTaskDidCompleteErrorKey];
    NSURLSessionTask *task = note.object;
    if (!error) {
        // æˆåŠŸ
        [strongSelf.networkRecoder recordFinishRequestWithRequestID:task.cmn_requestId task:task];
    } else {
        // å¤±è´¥
        [strongSelf.networkRecoder recordResponseErrorWithRequestID:task.cmn_requestId task:task error:error];
    }
}];
```

åœ¨ networkRecoder çš„æ–¹æ³•é‡Œé¢å»ç»„è£…æ•°æ®ï¼Œäº¤ç»™æ•°æ®ä¸ŠæŠ¥ç»„ä»¶ï¼Œç­‰åˆ°åˆé€‚çš„æ—¶æœºç­–ç•¥å»ä¸ŠæŠ¥ã€‚

å› ä¸ºç½‘ç»œæ˜¯ä¸€ä¸ªå¼‚æ­¥çš„è¿‡ç¨‹ï¼Œæ‰€ä»¥å½“ç½‘ç»œè¯·æ±‚å¼€å§‹çš„æ—¶å€™éœ€è¦ä¸ºæ¯ä¸ªç½‘ç»œè®¾ç½®å”¯ä¸€æ ‡è¯†ï¼Œç­‰åˆ°ç½‘ç»œè¯·æ±‚å®Œæˆåå†æ ¹æ®æ¯ä¸ªè¯·æ±‚çš„æ ‡è¯†ï¼Œåˆ¤æ–­è¯¥ç½‘ç»œè€—æ—¶å¤šä¹…ã€æ˜¯å¦æˆåŠŸç­‰ã€‚æ‰€ä»¥æªæ–½æ˜¯ä¸º **NSURLSessionTask** æ·»åŠ åˆ†ç±»ï¼Œé€šè¿‡ runtime å¢åŠ ä¸€ä¸ªå±æ€§ï¼Œä¹Ÿå°±æ˜¯å”¯ä¸€æ ‡è¯†ã€‚

è¿™é‡Œæ’ä¸€å˜´ï¼Œä¸º Category å‘½åã€ä»¥åŠå†…éƒ¨çš„å±æ€§å’Œæ–¹æ³•å‘½åçš„æ—¶å€™éœ€è¦æ³¨æ„ä¸‹ã€‚å‡å¦‚ä¸æ³¨æ„ä¼šæ€ä¹ˆæ ·å‘¢ï¼Ÿå‡å¦‚ä½ è¦ä¸º NSString ç±»å¢åŠ èº«ä»½è¯å·ç ä¸­é—´ä½æ•°éšè—çš„åŠŸèƒ½ï¼Œé‚£ä¹ˆå†™ä»£ç ä¹…äº†çš„è€å¸æœº Aï¼Œä¸º NSString å¢åŠ äº†ä¸€ä¸ªæ–¹æ³•åï¼Œå«åš getMaskedIdCardNumberï¼Œä½†æ˜¯ä»–çš„éœ€æ±‚æ˜¯ä» [9, 12] è¿™4ä½å­—ç¬¦ä¸²éšè—æ‰ã€‚è¿‡äº†å‡ å¤©åŒäº‹ B ä¹Ÿé‡åˆ°äº†ç±»ä¼¼çš„éœ€æ±‚ï¼Œä»–ä¹Ÿæ˜¯ä¸€ä½è€å¸æœºï¼Œä¸º NSString å¢åŠ äº†ä¸€ä¸ªä¹Ÿå« getMaskedIdCardNumber çš„æ–¹æ³•ï¼Œä½†æ˜¯ä»–çš„éœ€æ±‚æ˜¯ä» [8, 11] è¿™4ä½å­—ç¬¦ä¸²éšè—ï¼Œä½†æ˜¯ä»–å¼•å…¥å·¥ç¨‹åå‘ç°è¾“å‡ºå¹¶ä¸ç¬¦åˆé¢„æœŸï¼Œä¸ºè¯¥æ–¹æ³•å†™çš„å•æµ‹æ²¡é€šè¿‡ï¼Œä»–ä»¥ä¸ºè‡ªå·±å†™é”™äº†æˆªå–æ–¹æ³•ï¼Œæ£€æŸ¥äº†å‡ éæ‰å‘ç°å·¥ç¨‹å¼•å…¥äº†å¦ä¸€ä¸ª NSString åˆ†ç±»ï¼Œé‡Œé¢çš„æ–¹æ³•åŒå ğŸ˜‚ çœŸå‘ã€‚

**ä¸‹é¢çš„ä¾‹å­æ˜¯ SDKï¼Œä½†æ˜¯æ—¥å¸¸å¼€å‘ä¹Ÿæ˜¯ä¸€æ ·ã€‚**

- Category ç±»åï¼šå»ºè®®æŒ‰ç…§å½“å‰ SDK åç§°çš„ç®€å†™ä½œä¸ºå‰ç¼€ï¼Œå†åŠ ä¸‹åˆ’çº¿ï¼Œå†åŠ å½“å‰åˆ†ç±»çš„åŠŸèƒ½ï¼Œä¹Ÿå°±æ˜¯`ç±»å+SDKåç§°ç®€å†™_åŠŸèƒ½åç§°`ã€‚æ¯”å¦‚å½“å‰ SDK å« JuhuaSuanAPMï¼Œé‚£ä¹ˆè¯¥ NSURLSessionTask Category åç§°å°±å«åš `NSURLSessionTask+JuHuaSuanAPM_NetworkMonitor.h`
- Category å±æ€§åï¼šå»ºè®®æŒ‰ç…§å½“å‰ SDK åç§°çš„ç®€å†™ä½œä¸ºå‰ç¼€ï¼Œå†åŠ ä¸‹åˆ’çº¿ï¼Œå†åŠ å±æ€§åï¼Œä¹Ÿå°±æ˜¯`SDKåç§°ç®€å†™_å±æ€§åç§°`ã€‚æ¯”å¦‚ JuhuaSuanAPM_requestId`
- Category æ–¹æ³•åï¼šå»ºè®®æŒ‰ç…§å½“å‰ SDK åç§°çš„ç®€å†™ä½œä¸ºå‰ç¼€ï¼Œå†åŠ ä¸‹åˆ’çº¿ï¼Œå†åŠ æ–¹æ³•åï¼Œä¹Ÿå°±æ˜¯`SDKåç§°ç®€å†™_æ–¹æ³•åç§°`ã€‚æ¯”å¦‚ `-(BOOL)JuhuaSuanAPM__isGzippedData`

ä¾‹å­å¦‚ä¸‹ï¼š

```
#import <Foundation/Foundation.h>

@interface NSURLSessionTask (JuhuaSuanAPM_NetworkMonitor)

@property (nonatomic, copy) NSString* JuhuaSuanAPM_requestId;

@end

#import "NSURLSessionTask+JuHuaSuanAPM_NetworkMonitor.h"
#import <objc/runtime.h>

@implementation NSURLSessionTask (JuHuaSuanAPM_NetworkMonitor)

- (NSString*)JuhuaSuanAPM_requestId
{
    return objc_getAssociatedObject(self, _cmd);
}

- (void)setJuhuaSuanAPM_requestId:(NSString*)requestId
{
    objc_setAssociatedObject(self, @selector(JuhuaSuanAPM_requestId), requestId, OBJC_ASSOCIATION_COPY_NONATOMIC);
}
@end
```

#### 2.5 iOS æµé‡ç›‘æ§

##### 2.5.1 HTTP è¯·æ±‚ã€å“åº”æ•°æ®ç»“æ„

**HTTP è¯·æ±‚æŠ¥æ–‡ç»“æ„**

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094901633.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

**å“åº”æŠ¥æ–‡çš„ç»“æ„**

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094922653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

1. HTTP æŠ¥æ–‡æ˜¯æ ¼å¼åŒ–çš„æ•°æ®å—ï¼Œæ¯æ¡æŠ¥æ–‡ç”±ä¸‰éƒ¨åˆ†ç»„æˆï¼šå¯¹æŠ¥æ–‡è¿›è¡Œæè¿°çš„èµ·å§‹è¡Œã€åŒ…å«å±æ€§çš„é¦–éƒ¨å—ã€ä»¥åŠå¯é€‰çš„åŒ…å«æ•°æ®çš„ä¸»ä½“éƒ¨åˆ†ã€‚
2. èµ·å§‹è¡Œå’Œæ‰‹éƒ¨å°±æ˜¯ç”±è¡Œåˆ†éš”ç¬¦çš„ ASCII æ–‡æœ¬ï¼Œæ¯è¡Œéƒ½ä»¥ä¸€ä¸ªç”±2ä¸ªå­—ç¬¦ç»„æˆçš„è¡Œç»ˆæ­¢åºåˆ—ä½œä¸ºç»“æŸï¼ˆåŒ…æ‹¬ä¸€ä¸ªå›è½¦ç¬¦ã€ä¸€ä¸ªæ¢è¡Œç¬¦ï¼‰
3. å®ä½“çš„ä¸»ä½“æˆ–è€…æŠ¥æ–‡çš„ä¸»ä½“æ˜¯ä¸€ä¸ªå¯é€‰çš„æ•°æ®å—ã€‚ä¸èµ·å§‹è¡Œå’Œé¦–éƒ¨ä¸åŒçš„æ˜¯ï¼Œä¸»ä½“ä¸­å¯ä»¥åŒ…å«æ–‡æœ¬æˆ–è€…äºŒè¿›åˆ¶æ•°æ®ï¼Œä¹Ÿå¯ä»¥ä¸ºç©ºã€‚
4. HTTP é¦–éƒ¨ï¼ˆä¹Ÿå°±æ˜¯ Headersï¼‰æ€»æ˜¯åº”è¯¥ä»¥ä¸€ä¸ªç©ºè¡Œç»“æŸï¼Œå³ä½¿æ²¡æœ‰å®ä½“éƒ¨åˆ†ã€‚æµè§ˆå™¨å‘é€äº†ä¸€ä¸ªç©ºç™½è¡Œæ¥é€šçŸ¥æœåŠ¡å™¨ï¼Œå®ƒå·²ç»ç»“æŸäº†è¯¥å¤´ä¿¡æ¯çš„å‘é€ã€‚

**è¯·æ±‚æŠ¥æ–‡çš„æ ¼å¼**

```
<method> <request-URI> <version>
<headers>

<entity-body>
```

**å“åº”æŠ¥æ–‡çš„æ ¼å¼**

```
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

ä¸‹å›¾æ˜¯æ‰“å¼€ Chrome æŸ¥çœ‹æè¯¾æ—¶é—´ç½‘é¡µçš„è¯·æ±‚ä¿¡æ¯ã€‚åŒ…æ‹¬å“åº”è¡Œã€å“åº”å¤´ã€å“åº”ä½“ç­‰ä¿¡æ¯ã€‚

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714094956985.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

ä¸‹å›¾æ˜¯åœ¨ç»ˆç«¯ä½¿ç”¨ `curl` æŸ¥çœ‹ä¸€ä¸ªå®Œæ•´çš„è¯·æ±‚å’Œå“åº”æ•°æ®

![åœ¨è¿™é‡Œæ’å…¥å›¾ç‰‡æè¿°](https://img-blog.csdnimg.cn/20200714095018903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTI0Mzk0NDY=,size_16,color_FFFFFF,t_70#pic_center)

æˆ‘ä»¬éƒ½çŸ¥é“åœ¨ HTTP é€šä¿¡ä¸­ï¼Œå“åº”æ•°æ®ä¼šä½¿ç”¨ gzip æˆ–å…¶ä»–å‹ç¼©æ–¹å¼å‹ç¼©ï¼Œç”¨ NSURLProtocol ç­‰æ–¹æ¡ˆç›‘å¬ï¼Œç”¨ NSData ç±»å‹å»è®¡ç®—åˆ†ææµé‡ç­‰ä¼šé€ æˆæ•°æ®çš„ä¸ç²¾ç¡®ï¼Œå› ä¸ºæ­£å¸¸ä¸€ä¸ª HTTP å“åº”ä½“çš„å†…å®¹æ˜¯ä½¿ç”¨ gzip æˆ–å…¶ä»–å‹ç¼©æ–¹å¼å‹ç¼©çš„ï¼Œæ‰€ä»¥ä½¿ç”¨ NSData ä¼šåå¤§ã€‚

##### 2.5.2 é—®é¢˜

1. Request å’Œ Response ä¸ä¸€å®šæˆå¯¹å­˜åœ¨

   æ¯”å¦‚ç½‘ç»œæ–­å¼€ã€App çªç„¶ Crash ç­‰ï¼Œæ‰€ä»¥ Request å’Œ Response ç›‘æ§åä¸åº”è¯¥è®°å½•åœ¨ä¸€æ¡è®°å½•é‡Œ

2. è¯·æ±‚æµé‡è®¡ç®—æ–¹å¼ä¸ç²¾ç¡®

   ä¸»è¦åŸå› æœ‰ï¼š

   - ç›‘æ§æŠ€æœ¯æ–¹æ¡ˆå¿½ç•¥äº†è¯·æ±‚å¤´å’Œè¯·æ±‚è¡Œéƒ¨åˆ†çš„æ•°æ®å¤§å°
   - ç›‘æ§æŠ€æœ¯æ–¹æ¡ˆå¿½ç•¥äº† Cookie éƒ¨åˆ†çš„æ•°æ®å¤§å°
   - ç›‘æ§æŠ€æœ¯æ–¹æ¡ˆåœ¨å¯¹è¯·æ±‚ä½“å¤§å°è®¡ç®—çš„æ—¶å€™ç›´æ¥ä½¿ç”¨ `HTTPBody.length`ï¼Œå¯¼è‡´ä¸å¤Ÿç²¾ç¡®

3. å“åº”æµé‡è®¡ç®—æ–¹å¼ä¸ç²¾ç¡®

   ä¸»è¦åŸå› æœ‰ï¼š

   - ç›‘æ§æŠ€æœ¯æ–¹æ¡ˆå¿½ç•¥äº†å“åº”å¤´å’Œå“åº”è¡Œéƒ¨åˆ†çš„æ•°æ®å¤§å°
   - ç›‘æ§æŠ€æœ¯æ–¹æ¡ˆåœ¨å¯¹ body éƒ¨åˆ†çš„å­—èŠ‚å¤§å°è®¡ç®—ï¼Œå› é‡‡ç”¨ `exceptedContentLength` å¯¼è‡´ä¸å¤Ÿå‡†ç¡®
   - ç›‘æ§æŠ€æœ¯æ–¹æ¡ˆå¿½ç•¥äº†å“åº”ä½“ä½¿ç”¨ gzip å‹ç¼©ã€‚çœŸæ­£çš„ç½‘ç»œé€šä¿¡è¿‡ç¨‹ä¸­ï¼Œå®¢æˆ·ç«¯åœ¨å‘èµ·è¯·æ±‚çš„è¯·æ±‚å¤´ä¸­ `Accept-Encoding` å­—æ®µä»£è¡¨å®¢æˆ·ç«¯æ”¯æŒçš„æ•°æ®å‹ç¼©æ–¹å¼ï¼ˆè¡¨æ˜å®¢æˆ·ç«¯å¯ä»¥æ­£å¸¸ä½¿ç”¨æ•°æ®æ—¶æ”¯æŒçš„å‹ç¼©æ–¹æ³•ï¼‰ï¼ŒåŒæ ·æœåŠ¡ç«¯æ ¹æ®å®¢æˆ·ç«¯æƒ³è¦çš„å‹ç¼©æ–¹å¼ã€æœåŠ¡ç«¯å½“å‰æ”¯æŒçš„å‹ç¼©æ–¹å¼ï¼Œæœ€åå¤„ç†æ•°æ®ï¼Œåœ¨å“åº”å¤´ä¸­`Content-Encoding` å­—æ®µè¡¨ç¤ºå½“å‰æœåŠ¡å™¨é‡‡ç”¨äº†ä»€ä¹ˆå‹ç¼©æ–¹å¼ã€‚

##### 2.5.3 æŠ€æœ¯å®ç°

ç¬¬äº”éƒ¨åˆ†è®²äº†ç½‘ç»œæ‹¦æˆªçš„å„ç§åŸç†å’ŒæŠ€æœ¯æ–¹æ¡ˆï¼Œè¿™é‡Œæ‹¿ NSURLProtocol æ¥è¯´å®ç°æµé‡ç›‘æ§ï¼ˆHook çš„æ–¹å¼ï¼‰ã€‚ä»ä¸Šè¿°çŸ¥é“äº†æˆ‘ä»¬éœ€è¦ä»€ä¹ˆæ ·çš„ï¼Œé‚£ä¹ˆå°±é€æ­¥å®ç°å§ã€‚

###### 2.5.3.1 Request éƒ¨åˆ†

1. å…ˆåˆ©ç”¨ç½‘ç»œç›‘æ§æ–¹æ¡ˆå°† NSURLProtocol ç®¡ç† App çš„å„ç§ç½‘ç»œè¯·æ±‚

2. åœ¨å„ä¸ªæ–¹æ³•å†…éƒ¨è®°å½•å„é¡¹æ‰€éœ€å‚æ•°ï¼ˆNSURLProtocol ä¸èƒ½åˆ†æè¯·æ±‚æ¡æ‰‹ã€æŒ¥æ‰‹ç­‰æ•°æ®å¤§å°å’Œæ—¶é—´æ¶ˆè€—ï¼Œä¸è¿‡å¯¹äºæ­£å¸¸æƒ…å†µçš„æ¥å£æµé‡åˆ†æè¶³å¤Ÿäº†ï¼Œæœ€åº•å±‚éœ€è¦ Socket å±‚ï¼‰

   ```
   @property(nonatomic, strong) NSURLConnection *internalConnection;
   @property(nonatomic, strong) NSURLResponse *internalResponse;
   @property(nonatomic, strong) NSMutableData *responseData;
   @property (nonatomic, strong) NSURLRequest *internalRequest;
   ```

   ```
   - (void)startLoading
   {
       NSMutableURLRequest *mutableRequest = [[self request] mutableCopy];
       self.internalConnection = [[NSURLConnection alloc] initWithRequest:mutableRequest delegate:self];
       self.internalRequest = self.request;
   }
      
   - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
   {
       [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
       self.internalResponse = response;
   }
      
   - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data 
   {
       [self.responseData appendData:data];
       [self.client URLProtocol:self didLoadData:data];
   }
   ```

3. Status Line éƒ¨åˆ†

NSURLResponse æ²¡æœ‰ Status Line ç­‰å±æ€§æˆ–è€…æ¥å£ï¼ŒHTTP Version ä¿¡æ¯ä¹Ÿæ²¡æœ‰ï¼Œæ‰€ä»¥è¦æƒ³è·å– Status Line æƒ³åŠæ³•è½¬æ¢åˆ° CFNetwork å±‚è¯•è¯•çœ‹ã€‚å‘ç°æœ‰ç§æœ‰ API å¯ä»¥å®ç°ã€‚

**æ€è·¯ï¼šå°† NSURLResponse é€šè¿‡ `_CFURLResponse` è½¬æ¢ä¸º `CFTypeRef`ï¼Œç„¶åå†å°† `CFTypeRef` è½¬æ¢ä¸º `CFHTTPMessageRef`ï¼Œå†é€šè¿‡ `CFHTTPMessageCopyResponseStatusLine` è·å– `CFHTTPMessageRef` çš„ Status Line ä¿¡æ¯ã€‚**

å°†è¯»å– Status Line çš„åŠŸèƒ½æ·»åŠ ä¸€ä¸ª NSURLResponse çš„åˆ†ç±»ã€‚

```
   // NSURLResponse+cm_FetchStatusLineFromCFNetwork.h
   #import <Foundation/Foundation.h>
   
   NS_ASSUME_NONNULL_BEGIN
   
   @interface NSURLResponse (cm_FetchStatusLineFromCFNetwork)
   
   - (NSString *)cm_fetchStatusLineFromCFNetwork;
   
   @end
   
   NS_ASSUME_NONNULL_END
   
   // NSURLResponse+cm_FetchStatusLineFromCFNetwork.m
   #import "NSURLResponse+cm_FetchStatusLineFromCFNetwork.h"
   #import <dlfcn.h>
   
   
   #define SuppressPerformSelectorLeakWarning(Stuff) \
   do { \
       _Pragma("clang diagnostic push") \
       _Pragma("clang diagnostic ignored \"-Warc-performSelector-leaks\"") \
       Stuff; \
       _Pragma("clang diagnostic pop") \
   } while (0)
   
   typedef CFHTTPMessageRef (*CMURLResponseFetchHTTPResponse)(CFURLRef response);
   
   @implementation NSURLResponse (cm_FetchStatusLineFromCFNetwork)
   
   - (NSString *)cm_fetchStatusLineFromCFNetwork
   {
       NSString *statusLine = @"";
       NSString *funcName = @"CFURLResponseGetHTTPResponse";
       CMURLResponseFetchHTTPResponse originalURLResponseFetchHTTPResponse = dlsym(RTLD_DEFAULT, [funcName UTF8String]);
       
       SEL getSelector = NSSelectorFromString(@"_CFURLResponse");
       if ([self respondsToSelector:getSelector] && NULL != originalURLResponseFetchHTTPResponse) {
           CFTypeRef cfResponse;
           SuppressPerformSelectorLeakWarning(
               cfResponse = CFBridgingRetain([self performSelector:getSelector]);
           );
           if (NULL != cfResponse) {
               CFHTTPMessageRef messageRef = originalURLResponseFetchHTTPResponse(cfResponse);
               statusLine = (__bridge_transfer NSString *)CFHTTPMessageCopyResponseStatusLine(messageRef);
               CFRelease(cfResponse);
           }
       }
       return statusLine;
   }
   
   @end
```

1. å°†è·å–åˆ°çš„ Status Line è½¬æ¢ä¸º NSDataï¼Œå†è®¡ç®—å¤§å°

   ```
   - (NSUInteger)cm_getLineLength {
       NSString *statusLineString = @"";
       if ([self isKindOfClass:[NSHTTPURLResponse class]]) {
           NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)self;
           statusLineString = [self cm_fetchStatusLineFromCFNetwork];
       }
       NSData *lineData = [statusLineString dataUsingEncoding:NSUTF8StringEncoding];
       return lineData.length;
   }
   ```

2. Header éƒ¨åˆ†

   `allHeaderFields` è·å–åˆ° NSDictionaryï¼Œç„¶åæŒ‰ç…§ `key: value` æ‹¼æ¥æˆå­—ç¬¦ä¸²ï¼Œç„¶åè½¬æ¢æˆ NSData è®¡ç®—å¤§å°

   æ³¨æ„ï¼š`key: value` key åæ˜¯æœ‰ç©ºæ ¼çš„ï¼Œcurl æˆ–è€… chrome Network é¢æ¿å¯ä»¥æŸ¥çœ‹å°è¯ä¸‹ã€‚

   ```
   - (NSUInteger)cm_getHeadersLength
   {
       NSUInteger headersLength = 0;
       if ([self isKindOfClass:[NSHTTPURLResponse class]]) {
           NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)self;
           NSDictionary *headerFields = httpResponse.allHeaderFields;
           NSString *headerString = @"";
           for (NSString *key in headerFields.allKeys) {
               headerString = [headerStr stringByAppendingString:key];
               headheaderStringerStr = [headerString stringByAppendingString:@": "];
               if ([headerFields objectForKey:key]) {
                   headerString = [headerString stringByAppendingString:headerFields[key]];
               }
               headerString = [headerString stringByAppendingString:@"\n"];
           }
           NSData *headerData = [headerString dataUsingEncoding:NSUTF8StringEncoding];
           headersLength = headerData.length;
       }
       return headersLength;
   }
   ```

3. Body éƒ¨åˆ†

   Body å¤§å°çš„è®¡ç®—ä¸èƒ½ç›´æ¥ä½¿ç”¨ excepectedContentLengthï¼Œå®˜æ–¹æ–‡æ¡£è¯´æ˜äº†å…¶ä¸å‡†ç¡®æ€§ï¼Œåªå¯ä»¥ä½œä¸ºå‚è€ƒã€‚æˆ–è€… `allHeaderFields` ä¸­çš„ `Content-Length` å€¼ä¹Ÿæ˜¯ä¸å¤Ÿå‡†ç¡®çš„ã€‚

   > /*!
   >
   > **@abstract** Returns the expected content length of the receiver.
   >
   > **@discussion** Some protocol implementations report a content length
   >
   > as part of delivering load metadata, but not all protocols
   >
   > guarantee the amount of data that will be delivered in actuality.
   >
   > Hence, this method returns an expected amount. Clients should use
   >
   > this value as an advisory, and should be prepared to deal with
   >
   > either more or less data.
   >
   > **@result** The expected content length of the receiver, or -1 if
   >
   > there is no expectation that can be arrived at regarding expected
   >
   > content length.
   >
   > */
   >
   > **@property** (**readonly**) **long** **long** expectedContentLength;

   - HTTP 1.1 ç‰ˆæœ¬è§„å®šï¼Œå¦‚æœå­˜åœ¨ `Transfer-Encoding: chunked`ï¼Œåˆ™åœ¨ header ä¸­ä¸èƒ½æœ‰ `Content-Length`ï¼Œæœ‰ä¹Ÿä¼šè¢«å¿½è§†ã€‚
   - åœ¨ HTTP 1.0åŠä¹‹å‰ç‰ˆæœ¬ä¸­ï¼Œ`content-length` å­—æ®µå¯æœ‰å¯æ— 
   - åœ¨ HTTP 1.1åŠä¹‹åç‰ˆæœ¬ã€‚å¦‚æœæ˜¯ `keep alive`ï¼Œåˆ™ `Content-Length` å’Œ `chunked` å¿…ç„¶æ˜¯äºŒé€‰ä¸€ã€‚è‹¥æ˜¯é`keep alive`ï¼Œåˆ™å’Œ HTTP 1.0ä¸€æ ·ã€‚`Content-Length` å¯æœ‰å¯æ— ã€‚

   ä»€ä¹ˆæ˜¯ `Transfer-Encoding: chunked`

   æ•°æ®ä»¥ä¸€ç³»åˆ—åˆ†å—çš„å½¢å¼è¿›è¡Œå‘é€ `Content-Length` é¦–éƒ¨åœ¨è¿™ç§æƒ…å†µä¸‹ä¸è¢«å‘é€. åœ¨æ¯ä¸€ä¸ªåˆ†å—çš„å¼€å¤´éœ€è¦æ·»åŠ å½“å‰åˆ†å—çš„é•¿åº¦, ä»¥åå…­è¿›åˆ¶çš„å½¢å¼è¡¨ç¤ºï¼Œåé¢ç´§è·Ÿç€ `\r\n` , ä¹‹åæ˜¯åˆ†å—æœ¬èº«, åé¢ä¹Ÿæ˜¯ `\r\n` ï¼Œç»ˆæ­¢å—æ˜¯ä¸€ä¸ªå¸¸è§„çš„åˆ†å—, ä¸åŒä¹‹å¤„åœ¨äºå…¶é•¿åº¦ä¸º0.

   æˆ‘ä»¬ä¹‹å‰æ‹¿ NSMutableData è®°å½•äº†æ•°æ®ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥åœ¨ `stopLoading `æ–¹æ³•ä¸­è®¡ç®—å‡º Body å¤§å°ã€‚æ­¥éª¤å¦‚ä¸‹ï¼š

   - åœ¨ `didReceiveData` ä¸­ä¸æ–­æ·»åŠ  data

     ```
     - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data
     {
         [self.responseData appendData:data];
         [self.client URLProtocol:self didLoadData:data];
     }
     ```

   - åœ¨ `stopLoading` æ–¹æ³•ä¸­æ‹¿åˆ° `allHeaderFields` å­—å…¸ï¼Œè·å– `Content-Encoding` key çš„å€¼ï¼Œå¦‚æœæ˜¯ **gzip**ï¼Œåˆ™åœ¨ `stopLoading` ä¸­å°† NSData å¤„ç†ä¸º gzip å‹ç¼©åçš„æ•°æ®ï¼Œå†è®¡ç®—å¤§å°ã€‚ï¼ˆgzip ç›¸å…³åŠŸèƒ½å¯ä»¥ä½¿ç”¨è¿™ä¸ª[å·¥å…·](https://github.com/nicklockwood/GZIP)ï¼‰

     éœ€è¦é¢å¤–è®¡ç®—ä¸€ä¸ªç©ºç™½è¡Œçš„é•¿åº¦

     ```
     - (void)stopLoadi
     {
         [self.internalConnection cancel];
          
         PCTNetworkTrafficModel *model = [[PCTNetworkTrafficModel alloc] init];
         model.path = self.request.URL.path;
         model.host = self.request.URL.host;
         model.type = DMNetworkTrafficDataTypeResponse;
         model.lineLength = [self.internalResponse cm_getStatusLineLength];
         model.headerLength = [self.internalResponse cm_getHeadersLength];
         model.emptyLineLength = [self.internalResponse cm_getEmptyLineLength];
         if ([self.dm_response isKindOfClass:[NSHTTPURLResponse class]]) {
             NSHTTPURLResponse *httpResponse = (NSHTTPURLResponse *)self.dm_response;
             NSData *data = self.dm_data;
             if ([[httpResponse.allHeaderFields objectForKey:@"Content-Encoding"] isEqualToString:@"gzip"]) {
                 data = [self.dm_data gzippedData];
             }
             model.bodyLength = data.length;
         }
         model.length = model.lineLength + model.headerLength + model.bodyLength + model.emptyLineLength;
         NSDictionary *networkTrafficDictionary = [model convertToDictionary];
         [[PrismClient sharedInstance] sendWithType:CMMonitorNetworkTrafficType meta:networkTrafficDictionary payload:nil];
     }
     ```

###### 2.5.3.2 Resquest éƒ¨åˆ†

1. å…ˆåˆ©ç”¨ç½‘ç»œç›‘æ§æ–¹æ¡ˆå°† NSURLProtocol ç®¡ç† App çš„å„ç§ç½‘ç»œè¯·æ±‚

2. åœ¨å„ä¸ªæ–¹æ³•å†…éƒ¨è®°å½•å„é¡¹æ‰€éœ€å‚æ•°ï¼ˆNSURLProtocol ä¸èƒ½åˆ†æè¯·æ±‚æ¡æ‰‹ã€æŒ¥æ‰‹ç­‰æ•°æ®å¤§å°å’Œæ—¶é—´æ¶ˆè€—ï¼Œä¸è¿‡å¯¹äºæ­£å¸¸æƒ…å†µçš„æ¥å£æµé‡åˆ†æè¶³å¤Ÿäº†ï¼Œæœ€åº•å±‚éœ€è¦ Socket å±‚ï¼‰

   ```
   @property(nonatomic, strong) NSURLConnection *internalConnection;
   @property(nonatomic, strong) NSURLResponse *internalResponse;
   @property(nonatomic, strong) NSMutableData *responseData;
   @property (nonatomic, strong) NSURLRequest *internalRequest;
   ```

   ```
   - (void)startLoading
   {
       NSMutableURLRequest *mutableRequest = [[self request] mutableCopy];
       self.internalConnection = [[NSURLConnection alloc] initWithRequest:mutableRequest delegate:self];
       self.internalRequest = self.request;
   }
      
   - (void)connection:(NSURLConnection *)connection didReceiveResponse:(NSURLResponse *)response
   {
       [self.client URLProtocol:self didReceiveResponse:response cacheStoragePolicy:NSURLCacheStorageNotAllowed];
       self.internalResponse = response;
   }
      
   - (void)connection:(NSURLConnection *)connection didReceiveData:(NSData *)data 
   {
       [self.responseData appendData:data];
       [self.client URLProtocol:self didLoadData:data];
   }
   ```

3. Status Line éƒ¨åˆ†

   å¯¹äº NSURLRequest æ²¡æœ‰åƒ NSURLResponse ä¸€æ ·çš„æ–¹æ³•æ‰¾åˆ° StatusLineã€‚æ‰€ä»¥å…œåº•æ–¹æ¡ˆæ˜¯è‡ªå·±æ ¹æ® Status Line çš„ç»“æ„ï¼Œè‡ªå·±æ‰‹åŠ¨æ„é€ ä¸€ä¸ªã€‚ç»“æ„ä¸ºï¼š`åè®®ç‰ˆæœ¬å·+ç©ºæ ¼+çŠ¶æ€ç +ç©ºæ ¼+çŠ¶æ€æ–‡æœ¬+æ¢è¡Œ`

   ä¸º NSURLRequest æ·»åŠ ä¸€ä¸ªä¸“é—¨è·å– Status Line çš„åˆ†ç±»ã€‚

   ```
   // NSURLResquest+cm_FetchStatusLineFromCFNetwork.m
   - (NSUInteger)cm_fetchStatusLineLength
   {
     NSString *statusLineString = [NSString stringWithFormat:@"%@ %@ %@\n", self.HTTPMethod, self.URL.path, @"HTTP/1.1"];
     NSData *statusLineData = [statusLineString dataUsingEncoding:NSUTF8StringEncoding];
     return statusLineData.length;
   }
   ```

4. Header éƒ¨åˆ†

   ä¸€ä¸ª HTTP è¯·æ±‚ä¼šå…ˆæ„å»ºåˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¼“å­˜ï¼Œç„¶åè¿›è¡Œ DNS åŸŸåè§£æä»¥è·å–è¯·æ±‚åŸŸåçš„æœåŠ¡å™¨ IP åœ°å€ã€‚å¦‚æœè¯·æ±‚åè®®æ˜¯ HTTPSï¼Œé‚£ä¹ˆè¿˜éœ€è¦å»ºç«‹ TLS è¿æ¥ã€‚æ¥ä¸‹æ¥å°±æ˜¯åˆ©ç”¨ IP åœ°å€å’ŒæœåŠ¡å™¨å»ºç«‹ TCP è¿æ¥ã€‚è¿æ¥å»ºç«‹ä¹‹åï¼Œæµè§ˆå™¨ç«¯ä¼šæ„å»ºè¯·æ±‚è¡Œã€è¯·æ±‚å¤´ç­‰ä¿¡æ¯ï¼Œå¹¶æŠŠå’Œè¯¥åŸŸåç›¸å…³çš„ Cookie ç­‰æ•°æ®é™„åŠ åˆ°è¯·æ±‚å¤´ä¸­ï¼Œç„¶åå‘æœåŠ¡å™¨å‘é€æ„å»ºçš„è¯·æ±‚ä¿¡æ¯ã€‚

   æ‰€ä»¥ä¸€ä¸ªç½‘ç»œç›‘æ§ä¸è€ƒè™‘ cookie ğŸ˜‚ï¼Œå€Ÿç”¨ç‹å¤šé±¼çš„ä¸€å¥è¯ã€Œé‚£ä¸å®ŒçŠŠå­äº†å—ã€ã€‚

   çœ‹è¿‡ä¸€äº›æ–‡ç« è¯´ NSURLRequest ä¸èƒ½å®Œæ•´è·å–åˆ°è¯·æ±‚å¤´ä¿¡æ¯ã€‚å…¶å®é—®é¢˜ä¸å¤§ï¼Œ å‡ ä¸ªä¿¡æ¯è·å–ä¸å®Œå…¨ä¹Ÿæ²¡åŠæ³•ã€‚è¡¡é‡ç›‘æ§æ–¹æ¡ˆæœ¬èº«å°±æ˜¯çœ‹æ¥å£åœ¨ä¸åŒç‰ˆæœ¬æˆ–è€…æŸäº›æƒ…å†µä¸‹æ•°æ®æ¶ˆè€—æ˜¯å¦å¼‚å¸¸ï¼ŒWebView èµ„æºè¯·æ±‚æ˜¯å¦è¿‡å¤§ï¼Œç±»ä¼¼äºæ§åˆ¶å˜é‡æ³•çš„æ€æƒ³ã€‚

   æ‰€ä»¥è·å–åˆ° NSURLRequest çš„ `allHeaderFields` åï¼ŒåŠ ä¸Š cookie ä¿¡æ¯ï¼Œè®¡ç®—å®Œæ•´çš„ Header å¤§å°

   ```
   // NSURLResquest+cm_FetchHeaderWithCookies.m
   - (NSUInteger)cm_fetchHeaderLengthWithCookie
   {
       NSDictionary *headerFields = self.allHTTPHeaderFields;
       NSDictionary *cookiesHeader = [self cm_fetchCookies];
      
       if (cookiesHeader.count) {
           NSMutableDictionary *headerDictionaryWithCookies = [NSMutableDictionary dictionaryWithDictionary:headerFields];
           [headerDictionaryWithCookies addEntriesFromDictionary:cookiesHeader];
           headerFields = [headerDictionaryWithCookies copy];
       }
          
       NSString *headerString = @"";
      
       for (NSString *key in headerFields.allKeys) {
           headerString = [headerString stringByAppendingString:key];
           headerString = [headerString stringByAppendingString:@": "];
           if ([headerFields objectForKey:key]) {
               headerString = [headerString stringByAppendingString:headerFields[key]];
           }
           headerString = [headerString stringByAppendingString:@"\n"];
       }
       NSData *headerData = [headerString dataUsingEncoding:NSUTF8StringEncoding];
       headersLength = headerData.length;
       return headerString;
   }
      
   - (NSDictionary *)cm_fetchCookies
   {
       NSDictionary *cookiesHeaderDictionary;
       NSHTTPCookieStorage *cookieStorage = [NSHTTPCookieStorage sharedHTTPCookieStorage];
       NSArray<NSHTTPCookie *> *cookies = [cookieStorage cookiesForURL:self.URL];
       if (cookies.count) {
           cookiesHeaderDictionary = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
       }
       return cookiesHeaderDictionary;
   }
   ```

5. Body éƒ¨åˆ†

   NSURLConnection çš„ `HTTPBody` æœ‰å¯èƒ½è·å–ä¸åˆ°ï¼Œé—®é¢˜ç±»ä¼¼äº WebView ä¸Š ajax ç­‰æƒ…å†µã€‚æ‰€ä»¥å¯ä»¥é€šè¿‡ `HTTPBodyStream` è¯»å– stream æ¥è®¡ç®— body å¤§å°.

   ```
   - (NSUInteger)cm_fetchRequestBody
   {
       NSDictionary *headerFields = self.allHTTPHeaderFields;
       NSUInteger bodyLength = [self.HTTPBody length];
      
       if ([headerFields objectForKey:@"Content-Encoding"]) {
           NSData *bodyData;
           if (self.HTTPBody == nil) {
               uint8_t d[1024] = {0};
               NSInputStream *stream = self.HTTPBodyStream;
               NSMutableData *data = [[NSMutableData alloc] init];
               [stream open];
               while ([stream hasBytesAvailable]) {
                   NSInteger len = [stream read:d maxLength:1024];
                   if (len > 0 && stream.streamError == nil) {
                       [data appendBytes:(void *)d length:len];
                   }
               }
               bodyData = [data copy];
               [stream close];
           } else {
               bodyData = self.HTTPBody;
           }
           bodyLength = [[bodyData gzippedData] length];
       }
       return bodyLength;
   }
   ```

6. åœ¨ `- (NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response` æ–¹æ³•ä¸­å°†æ•°æ®ä¸ŠæŠ¥ä¼šåœ¨ [æ‰“é€ åŠŸèƒ½å¼ºå¤§ã€çµæ´»å¯é…ç½®çš„æ•°æ®ä¸ŠæŠ¥ç»„ä»¶](https://github.com/FantasticLBP/knowledge-kit/blob/master/Chapter1 - iOS/1.80.md) è®²

   ```
   -(NSURLRequest *)connection:(NSURLConnection *)connection willSendRequest:(NSURLRequest *)request redirectResponse:(NSURLResponse *)response
   {
       if (response != nil) {
           self.internalResponse = response;
           [self.client URLProtocol:self wasRedirectedToRequest:request redirectResponse:response];
       }
      
       PCTNetworkTrafficModel *model = [[PCTNetworkTrafficModel alloc] init];
       model.path = request.URL.path;
       model.host = request.URL.host;
       model.type = DMNetworkTrafficDataTypeRequest;
       model.lineLength = [connection.currentRequest dgm_getLineLength];
       model.headerLength = [connection.currentRequest dgm_getHeadersLengthWithCookie];
       model.bodyLength = [connection.currentRequest dgm_getBodyLength];
       model.emptyLineLength = [self.internalResponse cm_getEmptyLineLength];
       model.length = model.lineLength + model.headerLength + model.bodyLength + model.emptyLineLength;
          
       NSDictionary *networkTrafficDictionary = [model convertToDictionary];
       [[PrismClient sharedInstance] sendWithType:CMMonitorNetworkTrafficType meta:networkTrafficDictionary payload:nil];
       return request;
   }
   ```

## å…­ã€ ç”µé‡æ¶ˆè€—

ç§»åŠ¨è®¾å¤‡ä¸Šç”µé‡ä¸€ç›´æ˜¯æ¯”è¾ƒæ•æ„Ÿçš„é—®é¢˜ï¼Œå¦‚æœç”¨æˆ·åœ¨æŸæ¬¾ App çš„æ—¶å€™å‘ç°è€—ç”µé‡ä¸¥é‡ã€æ‰‹æœºå‘çƒ­ä¸¥é‡ï¼Œé‚£ä¹ˆç”¨æˆ·å¾ˆå¤§å¯èƒ½ä¼šé©¬ä¸Šå¸è½½è¿™æ¬¾ Appã€‚æ‰€ä»¥éœ€è¦åœ¨å¼€å‘é˜¶æ®µå…³å¿ƒè€—ç”µé‡é—®é¢˜ã€‚

ä¸€èˆ¬æ¥è¯´é‡åˆ°è€—ç”µé‡è¾ƒå¤§ï¼Œæˆ‘ä»¬ç«‹é©¬ä¼šæƒ³åˆ°æ˜¯ä¸æ˜¯ä½¿ç”¨äº†å®šä½ã€æ˜¯ä¸æ˜¯ä½¿ç”¨äº†é¢‘ç¹ç½‘ç»œè¯·æ±‚ã€æ˜¯ä¸æ˜¯ä¸æ–­å¾ªç¯åšæŸä»¶äº‹æƒ…ï¼Ÿ

å¼€å‘é˜¶æ®µåŸºæœ¬æ²¡å•¥é—®é¢˜ï¼Œæˆ‘ä»¬å¯ä»¥ç»“åˆ `Instrucments` é‡Œçš„ `Energy Log` å·¥å…·æ¥å®šä½é—®é¢˜ã€‚ä½†æ˜¯çº¿ä¸Šé—®é¢˜å°±éœ€è¦ä»£ç å»ç›‘æ§è€—ç”µé‡ï¼Œå¯ä»¥ä½œä¸º APM çš„èƒ½åŠ›ä¹‹ä¸€ã€‚

### 1. å¦‚ä½•è·å–ç”µé‡

åœ¨ iOS ä¸­ï¼Œ`IOKit` æ˜¯ä¸€ä¸ªç§æœ‰æ¡†æ¶ï¼Œç”¨æ¥è·å–ç¡¬ä»¶å’Œè®¾å¤‡çš„è¯¦ç»†ä¿¡æ¯ï¼Œä¹Ÿæ˜¯ç¡¬ä»¶å’Œå†…æ ¸æœåŠ¡é€šä¿¡çš„åº•å±‚æ¡†æ¶ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡ `IOKit `æ¥è·å–ç¡¬ä»¶ä¿¡æ¯ï¼Œä»è€Œè·å–åˆ°ç”µé‡ä¿¡æ¯ã€‚æ­¥éª¤å¦‚ä¸‹ï¼š

- é¦–å…ˆåœ¨è‹¹æœå¼€æ”¾æºä»£ç  opensource ä¸­æ‰¾åˆ° [IOPowerSources.h](https://opensource.apple.com/source/IOKitUser/IOKitUser-647.6/ps.subproj/IOPowerSources.h.auto.html)ã€[IOPSKeys.h](https://opensource.apple.com/source/IOKitUser/IOKitUser-647.6/ps.subproj/IOPSKeys.h)ã€‚åœ¨ Xcode çš„ `Package Contents` é‡Œé¢æ‰¾åˆ° `IOKit.framework`ã€‚ è·¯å¾„ä¸º `/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneOS.platform/Developer/SDKs/iPhoneOS.sdk/System/Library/Frameworks/IOKit.framework`
- ç„¶åå°† IOPowerSources.hã€IOPSKeys.hã€IOKit.framework å¯¼å…¥é¡¹ç›®å·¥ç¨‹
- è®¾ç½® UIDevice çš„ batteryMonitoringEnabled ä¸º true
- è·å–åˆ°çš„è€—ç”µé‡ç²¾ç¡®åº¦ä¸º 1%

### 2. å®šä½é—®é¢˜

é€šå¸¸æˆ‘ä»¬é€šè¿‡ Instrucments é‡Œçš„ Energy Log è§£å†³äº†å¾ˆå¤šé—®é¢˜åï¼ŒApp ä¸Šçº¿äº†ï¼Œçº¿ä¸Šçš„è€—ç”µé‡è§£å†³å°±éœ€è¦ä½¿ç”¨ APM æ¥è§£å†³äº†ã€‚è€—ç”µåœ°æ–¹å¯èƒ½æ˜¯äºŒæ–¹åº“ã€ä¸‰æ–¹åº“ï¼Œä¹Ÿå¯èƒ½æ˜¯æŸä¸ªåŒäº‹çš„ä»£ç ã€‚

æ€è·¯æ˜¯ï¼šåœ¨æ£€æµ‹åˆ°è€—ç”µåï¼Œå…ˆæ‰¾åˆ°æœ‰é—®é¢˜çš„çº¿ç¨‹ï¼Œç„¶åå †æ ˆ dumpï¼Œè¿˜åŸæ¡ˆå‘ç°åœºã€‚

åœ¨ä¸Šé¢éƒ¨åˆ†æˆ‘ä»¬çŸ¥é“äº†çº¿ç¨‹ä¿¡æ¯çš„ç»“æ„ï¼Œ `thread_basic_info` ä¸­æœ‰ä¸ªè®°å½• CPU ä½¿ç”¨ç‡ç™¾åˆ†æ¯”çš„å­—æ®µ `cpu_usage`ã€‚æ‰€ä»¥æˆ‘ä»¬å¯ä»¥é€šè¿‡éå†å½“å‰çº¿ç¨‹ï¼Œåˆ¤æ–­å“ªä¸ªçº¿ç¨‹çš„ CPU ä½¿ç”¨ç‡è¾ƒé«˜ï¼Œä»è€Œæ‰¾å‡ºæœ‰é—®é¢˜çš„çº¿ç¨‹ã€‚ç„¶åå† dump å †æ ˆï¼Œä»è€Œå®šä½åˆ°å‘ç”Ÿè€—ç”µé‡çš„ä»£ç ã€‚è¯¦ç»†è¯·çœ‹ [3.2](http://www.gsnice.com/2020/07/å¸¦ä½ æ‰“é€ ä¸€å¥—-APM-ç›‘æ§ç³»ç»Ÿ-ä¸‰/#threadInfo) éƒ¨åˆ†ã€‚

```
- (double)fetchBatteryCostUsage
{
  // returns a blob of power source information in an opaque CFTypeRef
    CFTypeRef blob = IOPSCopyPowerSourcesInfo();
    // returns a CFArray of power source handles, each of type CFTypeRef
    CFArrayRef sources = IOPSCopyPowerSourcesList(blob);
    CFDictionaryRef pSource = NULL;
    const void *psValue;
    // returns the number of values currently in an array
    int numOfSources = CFArrayGetCount(sources);
    // error in CFArrayGetCount
    if (numOfSources == 0) {
        NSLog(@"Error in CFArrayGetCount");
        return -1.0f;
    }

    // calculating the remaining energy
    for (int i=0; i<numOfSources; i++) {
        // returns a CFDictionary with readable information about the specific power source
        pSource = IOPSGetPowerSourceDescription(blob, CFArrayGetValueAtIndex(sources, i));
        if (!pSource) {
            NSLog(@"Error in IOPSGetPowerSourceDescription");
            return -1.0f;
        }
        psValue = (CFStringRef) CFDictionaryGetValue(pSource, CFSTR(kIOPSNameKey));

        int curCapacity = 0;
        int maxCapacity = 0;
        double percentage;

        psValue = CFDictionaryGetValue(pSource, CFSTR(kIOPSCurrentCapacityKey));
        CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &curCapacity);

        psValue = CFDictionaryGetValue(pSource, CFSTR(kIOPSMaxCapacityKey));
        CFNumberGetValue((CFNumberRef)psValue, kCFNumberSInt32Type, &maxCapacity);

        percentage = ((double) curCapacity / (double) maxCapacity * 100.0f);
        NSLog(@"curCapacity : %d / maxCapacity: %d , percentage: %.1f ", curCapacity, maxCapacity, percentage);
        return percentage;
    }
    return -1.0f;
}
```

### 3. å¼€å‘é˜¶æ®µé’ˆå¯¹ç”µé‡æ¶ˆè€—æˆ‘ä»¬èƒ½åšä»€ä¹ˆ

CPU å¯†é›†è¿ç®—æ˜¯è€—ç”µé‡ä¸»è¦åŸå› ã€‚æ‰€ä»¥æˆ‘ä»¬å¯¹ CPU çš„ä½¿ç”¨éœ€è¦ç²¾æ‰“ç»†ç®—ã€‚å°½é‡é¿å…è®© CPU åšæ— ç”¨åŠŸã€‚å¯¹äºå¤§é‡æ•°æ®çš„å¤æ‚è¿ç®—ï¼Œå¯ä»¥å€ŸåŠ©æœåŠ¡å™¨çš„èƒ½åŠ›ã€GPU çš„èƒ½åŠ›ã€‚å¦‚æœæ–¹æ¡ˆè®¾è®¡å¿…é¡»æ˜¯åœ¨ CPU ä¸Šå®Œæˆæ•°æ®çš„è¿ç®—ï¼Œåˆ™å¯ä»¥åˆ©ç”¨ GCD æŠ€æœ¯ï¼Œä½¿ç”¨ `dispatch_block_create_with_qos_class(<#dispatch_block_flags_t flags#>, dispatch_qos_class_t qos_class, <#int relative_priority#>, <#^(void)block#>)()` å¹¶æŒ‡å®š é˜Ÿåˆ—çš„ qos ä¸º `QOS_CLASS_UTILITY`ã€‚å°†ä»»åŠ¡æäº¤åˆ°è¿™ä¸ªé˜Ÿåˆ—çš„ block ä¸­ï¼Œåœ¨ QOS_CLASS_UTILITY æ¨¡å¼ä¸‹ï¼Œç³»ç»Ÿé’ˆå¯¹å¤§é‡æ•°æ®çš„è®¡ç®—ï¼Œåšäº†ç”µé‡ä¼˜åŒ–

é™¤äº† CPU å¤§é‡è¿ç®—ï¼ŒI/O æ“ä½œä¹Ÿæ˜¯è€—ç”µä¸»è¦åŸå› ã€‚ä¸šç•Œå¸¸è§æ–¹æ¡ˆéƒ½æ˜¯å°†ã€Œç¢ç‰‡åŒ–çš„æ•°æ®å†™å…¥ç£ç›˜å­˜å‚¨ã€è¿™ä¸ªæ“ä½œå»¶åï¼Œå…ˆåœ¨å†…å­˜ä¸­èšåˆå—ï¼Œç„¶åå†è¿›è¡Œç£ç›˜å­˜å‚¨ã€‚ç¢ç‰‡åŒ–æ•°æ®å…ˆèšåˆï¼Œåœ¨å†…å­˜ä¸­è¿›è¡Œå­˜å‚¨çš„æœºåˆ¶ï¼ŒiOS æä¾› `NSCache` è¿™ä¸ªå¯¹è±¡ã€‚

NSCache æ˜¯çº¿ç¨‹å®‰å…¨çš„ï¼ŒNSCache ä¼šåœ¨è¾¾åˆ°è¾¾é¢„è®¾çš„ç¼“å­˜ç©ºé—´çš„æ¡ä»¶æ—¶æ¸…ç†ç¼“å­˜ï¼Œæ­¤æ—¶ä¼šè§¦å‘ `- (**void**)cache:(NSCache *)cache willEvictObject:(**id**)obj;` æ–¹æ³•å›è°ƒï¼Œåœ¨è¯¥æ–¹æ³•å†…éƒ¨å¯¹æ•°æ®è¿›è¡Œ I/O æ“ä½œï¼Œè¾¾åˆ°å°†èšåˆçš„æ•°æ® I/O å»¶åçš„ç›®çš„ã€‚I/O æ¬¡æ•°å°‘äº†ï¼Œå¯¹ç”µé‡çš„æ¶ˆè€—ä¹Ÿå°±å‡å°‘äº†ã€‚

NSCache çš„ä½¿ç”¨å¯ä»¥æŸ¥çœ‹ SDWebImage è¿™ä¸ªå›¾ç‰‡åŠ è½½æ¡†æ¶ã€‚åœ¨å›¾ç‰‡è¯»å–ç¼“å­˜å¤„ç†æ—¶ï¼Œæ²¡ç›´æ¥è¯»å–ç¡¬ç›˜æ–‡ä»¶ï¼ˆI/Oï¼‰ï¼Œè€Œæ˜¯ä½¿ç”¨ç³»ç»Ÿçš„ NSCacheã€‚

```
- (nullable UIImage *)imageFromMemoryCacheForKey:(nullable NSString *)key {
    return [self.memoryCache objectForKey:key];
}

- (nullable UIImage *)imageFromDiskCacheForKey:(nullable NSString *)key {
    UIImage *diskImage = [self diskImageForKey:key];
    if (diskImage && self.config.shouldCacheImagesInMemory) {
        NSUInteger cost = diskImage.sd_memoryCost;
        [self.memoryCache setObject:diskImage forKey:key cost:cost];
    }

    return diskImage;
}
```

å¯ä»¥çœ‹åˆ°ä¸»è¦é€»è¾‘æ˜¯å…ˆä»ç£ç›˜ä¸­è¯»å–å›¾ç‰‡ï¼Œå¦‚æœé…ç½®å…è®¸å¼€å¯å†…å­˜ç¼“å­˜ï¼Œåˆ™å°†å›¾ç‰‡ä¿å­˜åˆ° NSCache ä¸­ï¼Œä½¿ç”¨çš„æ—¶å€™ä¹Ÿæ˜¯ä» NSCache ä¸­è¯»å–å›¾ç‰‡ã€‚NSCache çš„ `totalCostLimitã€countLimit` å±æ€§ï¼Œ

`- (void)setObject:(ObjectType)obj forKey:(KeyType)key cost:(NSUInteger)g;` æ–¹æ³•ç”¨æ¥è®¾ç½®ç¼“å­˜æ¡ä»¶ã€‚æ‰€ä»¥æˆ‘ä»¬å†™ç£ç›˜ã€å†…å­˜çš„æ–‡ä»¶æ“ä½œæ—¶å¯ä»¥å€Ÿé‰´è¯¥ç­–ç•¥ï¼Œä»¥ä¼˜åŒ–è€—ç”µé‡ã€‚