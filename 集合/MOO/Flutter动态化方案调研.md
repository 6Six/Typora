# **MOO APP动态化能力建设方案**



------





1. ## **背景与目标**

当前MOO已进入稳定的迭代开发阶段，每一版本发版周期大约为1月/版。这个发版周期虽然可以满足大部分需求，但是仍有很大的优化空间，获得更快的发版周期，提升发版效率。同时为满足AB测试，数据埋点等需求，我们希望为MOO引入动态化能力。

我们积极沟通了产品和测试，总结了几个动态化需求，以此确定我们需要实现怎么样的动态化能力。

如表1是动态化需求调查，产品针对动态化方案，希望加快版本迭代速率；并且能够方便的进行AB测试，即不同用户下发不同的AB代码；对于埋点能够更灵活地进行添加；部分活动或广告页面为H5页面，希望动态化能够替代H5页面，优化加载体验。

同时，测试对于动态化的期望是具有重大问题的回退容灾能力，可快速回退到上一版本代码；并且具有高稳定性，动态化内容加载不会导致崩溃或者界面异常等。

总结分析上述需求，我们的方案应当具备以下能力，并且以下能力都是可评估的：

1. 下发代码高成功率，高实时性，至少应当在用户第二次打开APP时就展示新的内容；
2. 支持多套代码同时下发，支持不同用户展示不同界面的能力；
3. 对原有的代码改动量尽可能地小，并且不改变原有的编码习惯，同时支持代码任意添加删除；
4. 必须保持Flutter的高性能渲染，不能影响到原有APP的性能；
5. 具备回退能力并增强线上问题修复能力；
6. 方案足够成熟，必须具备高稳定性，不可影响APP的整体稳定性；
7. App 架构的变更尽可能小；

同时我们还和产品讨论了类似天猫的Tangram的低代码方案，产品认为这类方案适用于发展较为成熟的产品，这类产品的模块已经成型，可通过低代码方式在APP中进行添加；而MOO还处于发展阶段，模块变更较为频繁，不适合低代码配置添加。但是，产品也提出，动态化现阶段不是MOO这款产品的重点，需求并不紧迫，所以即便要实施也是低优先级实施。

表1. 需求与目标



| 需求                                                         | 提出方 | 实现目标                                                     |
| ------------------------------------------------------------ | ------ | ------------------------------------------------------------ |
| 加快版本迭代速率（“当然希望所有需求都能用动态化”）           | 产品   | 高成功率，高实时性（至少第二次启动时应当展示新内容）；       |
| 实现方便的AB测试                                             | 产品   | 支持多套代码同时下发；                                       |
| 更灵活的埋点                                                 | 产品   | 支持代码任意添加删除，不改变原有的编码习惯；并且对原有代码改动量尽可能地少； |
| 替代H5页面实现快速加载                                       | 产品   | 必须保持Flutter的高性能渲染能力；                            |
| 具有重大问题的问题修复和回退容灾能力                         | 测试   | 具备回退能力并增强线上问题修复能力                           |
| 具有高稳定性（“APP被用户Kill的时候，动态化加载了一半，不会出现再打开崩溃或不显示”） | 测试   | 方案足够成熟，并且必须具备高稳定性；                         |



1. ## **理论基础**

动态化方案需要基于DartVM的编译原理来实现，本方案简单介绍DartVM在预先编译（AOT）场景下的编译原理。如图1为DartVM的编译流程（AOT场景）。整个编译过程主要包括了以下的关键步骤：

CFE：CFE（Common Front End）通过词法分析，语法分析，语义分析，将Dart源代码转变成kernel AST（抽象语法树）；

TFA：为AST生成精准的类型信息，并优化AST，如删除不可达方法等；

DartVM：优化好的AST通过AOT compilation toolchain将AST转换成IL，然后对IL进行一系列优化，最终生成AOT snapshot并加载执行。

​                 ![img](https://docimg7.docs.qq.com/image/yQlZXVrLIDTChZ1quDSVAg?w=1440&h=1440)        

图1. DartVM编译流程

1. 1. ### **面向前端开发的动态化方案**

如前所述，开发好的代码动态加载到APP上的时候，开发者需要为新添加的代码提供一套解释环境。面向前端的动态框架提供JS Engine来完成这个解释环境。这类动态化方案中的源代码是js代码。这些代码通过JS Engine进行解析生成Flutter的WidgetTree，再将WidgetTree转交给Flutter层进行编译，最终在Flutter Engine中进行渲染生成界面。

例如图2是Kraken方案的数据传递过程，JS Engine提供API处理界面div元素的添加（createElement(div)），该API最终会生成json格式的WidgetTree，该段json通过js和flutter间的通道传递给flutter层，flutter层解析json数据生成WidgetTree并最终渲染。数据传递过程Kraken定义了Kraken Bridge Protocol来完成。非页面渲染的逻辑处理，如点击或计算等，由JS Engine进行解析完成。

​                 ![img](https://docimg6.docs.qq.com/image/juyPGtYRiDGVuZHErMiZIA?w=1440&h=810)        

图2. Kraken的JS和flutter间的数据传递

这类方案主要面向的开发者拥有大量前端页面，并希望通过Flutter Engine获得比H5更好的页面加载渲染体验。同时保持了H5的动态更新能力。

目前市面上成型的方案有：MXFlutter，Tissue，Kraken，lite-app。

方案成熟度排名如表2所示。

Tissue是手Q小程序为特生页面渲染效果提出的一种解决方案。需要根据手Q小程序的标准书写代码。代码通过其逻辑层JavaScript框架编译成Virtual DOM Tree，然后转换Flutter的AST，再由Flutter去渲染。由于必须遵从小程序的标准去写代码，局限性很大。

MXFlutter提供了一套JSCore来解析TS或JS脚本。该套逻辑允许用户利用Dart的写法去书写JS脚本，类似的，最终也是由Flutter去渲染。该方案将在技术选型中进行介绍。

Kraken和lite-app提供了完全遵从W3C规范的DOM API，并配套了相应的JSEngine。这两个方案是对前端开发者最为友好的方案。另外lite-app还有一套完整的代码编译，上传，下发，加载支持，完成度已经非常高了。这两个方案将在技术选型中一起进行介绍。

表2. 面向前端开发方案排名



| 名次 | 方案      | 来源      |
| ---- | --------- | --------- |
| 1    | lite-app  | 微信团队  |
| 2    | Kraken    | 阿里      |
| 3    | MXFlutter | 手Q团队   |
| 4    | Tissue    | 手Q小程序 |



1. 1. ### **面向终端开发的动态化方案**

面向终端的方案并不提供JS Engine来支持对动态代码的解释，而是根据不同方案下发不同的产物，如表3所示是不同方案的优缺点。

其中下发编译产物官方支持，思路较为简单，flutter在Android中的业务代码在libapp.so中，只要将修复好的代码打包成新的libapp.so下发到APP上进行替换即可。目前的热修复大多应用了这个方案，并利用tinker对libapp.so进行差分更新，生成更小的补丁包。今年官方更新了defered components支持以aab为产物进行组件化动态更新。该方案虽然性能最好，但不支持iOS更新，是Android最为高效简单的方法，该方案作为备选方案之一。

下发源代码也是官方支持的方案，但是需要在APP上完成从源码开始到可执行文件的编译，包量大增。这类方案不考虑在选型当中。

UI DSL解释器是在生成AST过程中不提供必要的解释器而仅解析页面的静态WidgetTree，这类方案包括闲鱼动态化方案，ShapeWidget等，这类方案无法动态化加载页面上的方法逻辑，对于代码改动较大，这类方案不考虑在选型当中。

AST解释执行在生成AST过程中提供了解释器。这类方案如美团的MTFlutter（未开源）和DNFlutter。这类方案多端一致，支持方法逻辑。但是在Flutter快速迭代的背景下，该方案需要不断更新解释器以支持新的特性。

IL解释执行是将Dart代码编译成IL文件再进行下发，此时无论是页面还是业务逻辑都已经解释完成，是纯二进制文本。但是该方案产物层次较低，相应的方案代码对于业务开发人员来说难以维护；另外该方案仍处于发展早期，没有实际应用。

表3. 面向终端开发的动态化方案



| 动态化方式     | 实现原理                                                     | 优点                                     | 缺点                     |
| -------------- | ------------------------------------------------------------ | ---------------------------------------- | ------------------------ |
| 下发so或aab    | Android下发so或aab终端集成Dart Runtime，通过Dart AOT编译执行产物 | 官方支持性能无损耗                       | 不支持iOS                |
| 下发dart源码   | 直接下发源代码终端以JIT方式动态执行                          | 官方支持性能无损耗                       | 不支持iOS包量大增        |
| UI DSL静态解释 | 规避开发解释器；仅解析静态界面WidgetTree；                   | 支持全平台实现简单                       | 不支持业务逻辑           |
| AST解释器      | 对Dart源码进行语法分析，生成AST用于下发；终端实现AST解释器，支持业务逻辑 | 支持全平台支持业务逻辑                   | 语法迭代速度快，维护困难 |
| IL解释执行     | 将dart编译成IL再进行下发；                                   | 支持全平台支持业务逻辑绕过语法更新的问题 | 维护困难；发展早期       |



1. ## **技术选型**

2. 1. #### **MXFlutter**

如图3. MXFlutter是基于“用TypeScript或JavaScript，以Flutter的写法开发Flutter”，其SDK中内置了一个JS版本的Flutter SDK，用户可以书写类Dart代码，并利用JSCore将js代码运行起来，之后用JS版的Flutter SDK生成一个JS版的WidgetTree，再将WidgetTree转换成json序列通过JS-Dart通告从JS端传递到Dart端，最后映射成Dart的WidgetTree进行渲染。而业务逻辑部分，也是直接由JSCore解析，并通过JS-Dart通道传递给Flutter层。

方案优点：具有H5的动态能力同时具备Flutter的高渲染能力；

方案缺点：Flutter的写法开发界面增大了前端的开发成本，同时整个链路过长；其中包括了JS，JS WidgetTree，json和Flutter WidgetTree各个阶段的解析，但性能有所损耗，虽然官方未进行验证，但Q音对同类框架Kraken的性能测试证明了这一点。

​                 ![img](https://docimg5.docs.qq.com/image/RTb1JTdCDAxmM42hV32Emw?w=640&h=363)        

图3. 由js widget tree转换成flutter widget tree

1. 1. #### **Kraken/lite-app**

Kraken和Lite-app都是基于标准的W3C规范来提供JS API接口。同MXFlutter类似，它提供了一个JS Engine对代码进行解析并同Flutter层进行通信。据称其跨端通信的性能损耗较小，相比MXFlutter，有显著的提升。

lite-app是微信的解决方案，并在微信游戏当中进行了应用。相比Kraken成熟度更高，提供了代码打包，上传，下发，更新整套服务。

方案优点：对前端开发者最为友好。H5页面可以“0成本”接入。

方案缺点：从JS转化为Flutter必然会消耗性能，对于纯Flutter APP来说，这部分性能根本无必要。

1. 1. #### **IL-Dart**

IL是DartVM编译优化后的代码，其执行效率是最优的。IL-Dart是腾讯PCG的解决方案，暂未有应用，仅有Demo。将源码编译成IL后才对APP进行下发。

方案优点：性能无损耗

方案缺点：该方案实现对于业务开发者来说过于复杂，维护成本较大，当前发展早期，没有应用。

1. 1. #### **DNFlutter**

如图4. DNFlutter是公司内部的一个解决方案，其原理是利用Flutter代码在中间编译的时候生成的产物dill，dill中便包含了之前所述的AST。dill中的AST在编译过程中经过了类型推断（TFA），已经包含了完整的数据类型，继承，混入等信息。通过对应的解释器，可以生成完备的执行逻辑。相应的dill产物发送到APP，由Flutter进行AOT执行。

依据开发该方案的项目组介绍，该方案已经在手Q上线，PUBG手游社区已接入待上线，正在接入的包括：心悦俱乐部，FusionBank和腾讯医典。

Q音曾经对Kraken和DNFlutter进行了性能调研对比，对于我们较为关心的DNFlutter首次打开页面白屏时间和FPS如表4和表5所示。由此我们可以得出结论，DNFlutter的iOS侧性能稳定，白屏优秀，只有ListView长列表的FPS较低，但是其在Android的性能上有所损耗。Q音最终选择了Kraken作为动态化方案，原因是他们有大量的基于Hippy开发的js页面而期望通过将js页面转换到Flutter侧进行渲染而获得更优质的体验。这与我们纯Flutter开发有很大区别。如果使用基于JS的动态化方案，我们很可能需要重复开发我们原先使用dart开发的众多组件，延误进度。

进一步的，针对Android的性能损耗，我也进行了DNFlutter长列表和动画的性能测试，检测DNFlutter动态化应用和非动态化应用之间的性能差异。结果如表6，测试包括长列表（Scroller和ListView）的启动耗时以及长列表和动画列表的FPS，每一项测试测10组数据取平均值。从表中结果可看出，动态化页面启动耗时高出了非动态化页面5-6倍左右；在FPS测试中，长列表表现正常，但是动画列表FPS降低了一半以上。可见DNFlutter在Android上性能表现较差，损耗较大。

综上可终结，方案优点：方案成熟，并且在iOS侧具有稳定和优秀的性能；方案缺点：Android端性能有所损耗。另外DNFlutter依赖解释器符号表的生成，不支持动态添加第三方库，接入和调试有难度。

​                 ![img](https://docimg1.docs.qq.com/image/2EjhfMaa3TyFRNbk2jnSKg?w=1748&h=598)        

图4. DNFlutter的工作原理

表4. 页面白屏时间



| DNFlutter | iOS  | Android |
| --------- | ---- | ------- |
| 首帧时间  | 66ms | 231ms   |



表5. FPS对比



| FPS                                       | DNFlutter(iOS) | Kraken(iOS) | DNFlutter(Android) | Kraken(Android) |
| ----------------------------------------- | -------------- | ----------- | ------------------ | --------------- |
| case1(长列表, 500个列表项（Scroller）)    | 57             | 55          | 13.6               | 52.2            |
| case2（长列表，1000个列表项（ListView）） | 45             | 55          | 35.1               | 23.3            |
| case3（带动画的长列表，500个列表项）      | 60             | 9.7         | 18.3               | 3.6             |
| case4                                     | 59.9           |             | 59.5               | 59.8            |



表6-1. 长列表页面启动耗时测试



|                 | Scroller长列表（500项） | ListView长列表（1000项） |
| --------------- | ----------------------- | ------------------------ |
| DNFlutter动态化 | 1654ms                  | 115ms                    |
| 非动态化        | 276ms                   | 16ms                     |



表6-2. 长列表和动画列表的FPS



|                 | Scroller长列表（500项） | ListView长列表（1000项） | 动画列表 |
| --------------- | ----------------------- | ------------------------ | -------- |
| DNFlutter动态化 | 35.7                    | 55                       | 27       |
| 非动态化        | 38.4                    | 60                       | 60       |



1. 1. #### **补充报告**

我们在前述分析的基础上，分析了手Q接入DNFlutter的性能报表，并得出了相应的选型结论，[补充报告](https://docs.qq.com/doc/DTUxRcHV0amlMVG1j)

1. 1. #### **选型结论**

很明显，对于纯Flutter开发的MOO，面向终端开发的方案最适合我们。在这个范畴里，我们的选择有直接下发so，IL-Dart和DNFlutter。根据我们的目标，以编号进行打分（0-5，5分最高），如表6所示。直接下发so是效率最高的方案，但是下发so存在的严重弊端是仅支持Andorid，不支持iOS。在此我提出2种方案：

1. 两端均采用DNFlutter进行动态化开发，虽然具有性能损耗，但仍然在可接受范围内；
2. Android端采用直接下发so的方案，iOS采用DNFlutter方案，各取其优；但是打破了Flutter跨平台开发的优势，导致各端分别维护不同代码。

我们选择了第一种方案。

表6. 方案目标评分表



| 方案       | 目标1 | 目标2 | 目标3 | 目标4   | 目标5 | 目标6     | 目标7                         | 总分 |
| ---------- | ----- | ----- | ----- | ------- | ----- | --------- | ----------------------------- | ---- |
| 直接下发so | 5     | 5     | 5     | 5       | 5     | 5         | 5                             | 35   |
| IL-Dart    | 5     | 5     | 5     | 未知：0 | 5     | 不成熟：0 | 方案复杂：1                   | 21   |
| DNFlutter  | 5     | 5     | 5     | 损耗：2 | 5     | 5         | 添加解释器，接入调试有难度：3 | 30   |



1. ## **实施安排**



1. ## **参考文献**

【1】[Dart VM是如何运行你的代码的](https://zhuanlan.zhihu.com/p/100677736)

【2】[MXFlutter](https://git.woa.com/MXFlutter/MXFlutter)

【3】[Tissue](https://km.woa.com/group/19976/articles/show/413287)

【4】[Kraken](https://github.com/openkraken/kraken)

【5】[lite-app](https://git.woa.com/liteApp/wxa_lite_app)

【6】[DNFlutter](https://git.woa.com/QQWallet-iOS/DNFlutter)

【7】[IL-Dart](https://git.woa.com/ditto/tencent_dart_it)

【8】[Flutter 动态化方案对比研究：DNFlutter & Kraken](https://km.woa.com/group/22651/articles/show/472102?kmref=search&from_page=1&no=3)