# 迎接下一代网络传输协议-TQUIC协议栈研发实践



本文主要介绍STGW在TQUIC网络协议栈的研发实践经验，分享在协议栈研发、0-RTT握手、连接迁移、私有协议、实时传输等技术上的经验，我们也在拥塞调优、多路径传输、云端协同、精准调度等方向在持续深耕。本文整体侧重于从客户端痛点难点入手进行分析和解决，STGW在服务端接入上对QUIC协议栈性能、连接迁移、远程加解密等也做了很多工作，有兴趣同学可参见[STGW大规模运营QUIC之路](https://km.woa.com/group/11879/articles/show/455095)，结合起来阅读效果更佳。

## **一、QUIC/HTTP3协议介绍**

QUIC全称quick udp internet connection，“快速UDP互联网连接”，（和英文quick谐音，简称“快”）是由Google提出的基于UDP进行可靠传输的协议。QUIC在应用层实现了丢包恢复、拥塞控制、滑窗机制等保证数据传输的可靠性，同时对传输的数据具备前向安全的加密能力。HTTP3则是IETF(互联网工程任务组)基于QUIC协议基础进行设计的新一代HTTP协议。

QUIC/HTTP3分层模型及与HTTP2对比：

![img](https://km.woa.com/files/photos/pictures/202107/1627272519_3_w704_h439.png)



## **二、QUIC****核心优势是什么？**

- 0-RTT建立连接

QUIC基于的UDP协议本身无需握手，并且它早于TLS 1.3协议，就实现了自己的0-RTT加密握手。下图分别代表了1-RTT握手（首次建连），成功的0-RTT握手，以及失败回退的握手。

![img](https://km.woa.com/files/photos/pictures/202107/1627280769_78_w697_h350.png)

- 无队头阻塞的多路复用

相比于HTTP/2的多路复用，QUIC不会受到队头阻塞的影响，各个流更独立，多路复用的效果也更好。

![img](https://km.woa.com/files/photos/pictures/202107/1627280887_56_w666_h389.png)

- 连接迁移

跟TCP用四元组标识一个唯一连接不同，QUIC使用一个64位的ConnectionID来标识连接，基于这个特点，QUIC的使用连接迁移机制，在四元组发生变化时（比如客户端从WIFI切换到蜂窝网络），尝试“保留”先前的连接，从而维持数据传输不中断。

![img](https://km.woa.com/files/photos/pictures/202107/1627280937_6_w762_h354.png)

- 全应用态协议栈

QUIC核心逻辑都在用户态，能灵活的修改连接参数、替换拥塞算法、更改传输行为。而TCP动辄需要修改内核使得需要重启。



## 三、QUIC网络协议栈的选型

虽然QUIC各个特性看上去很美好，但需要客户端/服务端的网络协议栈都支持QUIC协议。截止到目前，各个主流OS的网络协议栈都未做支持。

![img](https://km.woa.com/files/photos/pictures/202107/1627281039_83_w675_h360.png)

如何让业务快速将QUIC协议用起来，用这些先进特性加速网络性能？

QUIC协议栈的实现成本非常高，主要体现在以下三方面

1. 实现复杂度很高，如上面介绍，QUIC/HTTP3横跨传输层、安全、应用层，相当于要把TCP+TLS+HTTP重新实现一次。
2. QUIC一直保持着高速发展，分为gQUIC（Google QUIC）、iQUIC(IETF-QUIC)两大类，衍生的QUIC子版本有几十个。

![img](https://km.woa.com/files/photos/pictures/202107/1627281076_72_w864_h106.png)

为了快速把QUIC协议落地，给业务提升网络性能，我们调研了开源的QUIC网络协议栈，做了分析和对比。

Chomium，作为占领全球浏览器绝对地位的Chrome的开源代码,有Google强大的研发团队支撑，其网络协议栈是一个相对独立的组件，被称为Cronet。

- 协议栈完整性：完善的QUIC协议栈，还包括HTTP2/WEBSOCKET/FTP/SOCKS协议。
- QUIC版本支持：支持gQUIC和iQUIC，并且还在不断保持更新。
- 跨平台性：非常好，基于chrome的跨平台能力，对于各类操作系统、终端都有适配。

Msquic，微软研发并开源的QUIC库。

- 协议栈完整性：只具备完整的QUIC协议栈。
- QUIC版本支持：仅支持iQUIC。
- 跨平台性：仅支持Windows、Linux。 

Nghttp3，IETF QUIC工作组针对QUIC做的标准实现

- 协议栈完整性：只具备完整的QUIC协议栈。
- QUIC版本支持：仅支持iQUIC。
- 跨平台性：Linux，同时未被大规模验证过。





## 四、基于Chromium Cronet的工程实践

从上述对QUIC开源网络库的调研分析来看，chromium cronet无疑是最合适的接入选型，那么Cronet能直接用起来吗？结合我们的实践与业务同学的反馈，直接使用的问题和接入困难度是比较大的。

问题一：代码体积过大，逻辑层级多，不利于集成和安装包体积控制（移动端）

Cronet核心及关联的第三方库代码有大概85w行，涉及2800多个类，其中核心的层级和功能梳理如下：

![img](https://km.woa.com/files/photos/pictures/202107/1627281154_17_w691_h600.png)

通过梳理分析可以看到，其实Cronet里大部分代码都与QUIC没有关系，由于其作为浏览器的网络协议栈，集成了大量浏览器行为逻辑，而这些能力对于网络协议栈是不需要的。

其次，QUIC协议只是Cronet里众多通信协议之一，除QUIC外的其他协议，通用的平台或软件（例如Nginx）本身就已经有实现，没有必要重复建设,这些协议的存在除了增加协议栈内部逻辑复杂度，还增大了整个库的体积，例如在安卓平台上，cronet动态库的体积接近3MB，这对于一些体积敏感的应用是一个巨大的挑战。 

针对体积问题，我们进行了代码精简和lib体积缩减的探究。

第一步，分析归纳

通过对cronet代码的分析和理解，冗余的代码被我们分成了四类：

1. 无用的内部逻辑：主要是代码内部的大量浏览器功能，会被调用链遍历到但对QUIC没有实际作用。例如HTTP PROXY、HTTP Cache、用户认证等。
2. 无需用到的的协议：例如FTP/Websocket/Spdy/Socks/WebRTC等协议，通常是通过派生类的方式在各个层级进行实现，衍生出了大量的代码。
3. 与quic无关的功能模块：例如连接池模块、trace模块、上报模块等。

第二步，代码裁剪

针对分析归纳中的三类问题，我们做了针对性的裁剪。

首先是精简了关键类，例如协议管控的类中，核心流程步骤被从21步压缩到了5步，函数数量从146个减少到24个，将浏览器相关的冗余逻辑去除。

接着对用不到的协议类型、模块组件做了剔除。裁剪后的效果如下：

![img](https://km.woa.com/files/photos/pictures/202107/1627281209_15_w689_h300.png)

问题二：Cronet的符号冲突

Cronet中除了google自己实现的代码外，还引用了较多的第三方库，比如protobuf、webrtc、boringssl。以boringssl为例，这是Google基于openssl进行二次开发的库。其函数符号与openssl是相同的，当把Cronet与项目工程集成并且项目工程中恰好还有同源的依赖库，就会发生编译冲突。其中静态编译的表现是直接在编译阶段报错，动态链接的表现则是在实际寻址时，只会找到其中一个符号并且执行，此时依赖另一个库同名函数的逻辑就会出现不可预期的错误。

![img](https://km.woa.com/files/photos/pictures/202107/1627281250_46_w664_h262.png)

针对这个问题，我们首先想的是统一第三方库，保证一个工程内只存在一个同源库，但Cronet中要么使用的是定制化的仓库(例如boringssl迎合了很多google需求，google声明并不推荐给其他工程使用)，要么对特定版本有依赖。直接统一或者强行改动，都可能会有预期外的结果。

对于boringssl这种同源但定制化程度较高的库，两者共存各自发挥作用会是更稳妥的选择。既然要共存，就要选择一个库进行符号更名。我们拿相对来说更独立的QUIC+BoringSSL尝试进行修改。

如图，为了做符号更改，必须对函数的定义处和引用处都做重命名，统计了一下这样的函数个数有3300多个，加上引用的地方，改动的地方达到了上万级别。这种改动方法繁重且过于低级。

![img](https://km.woa.com/files/photos/pictures/202107/1627281283_62_w677_h154.png)

经过一些方案对比和探索，最终我们想到了一种在编译阶段自动重命名符号的方法。

步骤1：使用nm导出全量对外符号表

![img](https://km.woa.com/files/photos/pictures/202107/1627281314_72_w750_h158.png)

步骤2：生成头文件进行全量符号define，增加命名前缀

![img](https://km.woa.com/files/photos/pictures/202107/1627281343_50_w750_h100.png)

步骤3：在预编译阶段引入头文件

步骤4：进行最后的链接，实现两个同源库的共存。

整个编译流程如下和效果如下：

![img](https://km.woa.com/files/photos/pictures/202107/1627281380_38_w727_h175.png)

通过这样的方式，只需要在编译quic的时候插入一个预处理头文件，在编译quic库过程，无论是符号的定义者还是引用者，在不修改原始代码的情况下，在生成的对象文件里，符号都被重命名掉了，做到了零代码入侵修改符号冲突，同时所有操作都是脚本化、自动化处理，极大的减少了人工操作成本。





## 五、打磨协议栈的易用性

虽然在工程方向，解决了体积大小和编译集成的问题。实际接入使用时，Cronet的易用性依然不够好。

通过挖掘业务需求，寻找共性，我们整理出了如下痛点

|                    | **需求**                                                     | **Cronet现状**                  |
| ------------------ | ------------------------------------------------------------ | ------------------------------- |
| IP直连通道         | •    跳过DNS过程，直连后端服务器                             | 强制要求通过域名DNS获取后端地址 |
| 灵活的网络参数配置 | •    超时时间配置•    拥塞控制、滑窗控制、竞速策略等配置     | 不支持直接配置                  |
| 性能数据打点       | •    获取连接、请求、首包时延•    获取0-RTT比例•    获取丢包重传、带宽情况 | 只有连接、请求、首包时延能获取  |

在通道直连方面，我们将底层udp socket粒度的接口进行封装后直接对外可见，用户可通过socket粒度的接口直接发起IP直连的QUIC请求，同时也保留了DNS建连能力，在保持原生能力的同时，拓展了用户的使用场景。

在网络参数配置和性能数据打点能力上，我们深入协议栈细节，逐个分析了多个核心模块，将关键的参数和性能数据抽象出来。

![img](https://km.woa.com/files/photos/pictures/202107/1627281477_86_w864_h397.png)

并在控制面上将配置参数、性能打点整合对外呈现。



## **六、进阶之路**

除了基础功能的打磨，TQUIC协议栈也提供了进阶功能进一步满足业务丰富的使用需求。

### **6.1 私有协议和明文传输**

在Cronet中，要想使用QUIC协议，应用层传输的报文必须是HTTP，也就是所谓的HTTP3协议。但HTTP报文对于游戏、音视频等业务是个巨大的阻碍，它们当前都是通过TCP或者UDP传输自定义的协议的，如果为了接入QUIC而把应用层数据从私有协议强行改为HTTP3，无疑是本末倒置。另外，由于是自定义协议，这些报文一般不需要QUIC进行加密，但加密是QUIC协议的标配，这会消耗额外的性能。

为此，在仔细研究了Quic核心代码后，我们研发对私有协议、明文传输的支持，来满足业务传输自定义协议的需求。

首先是在QuicStream中，允许stream直接收发数据报文，HTTP流程只是其中一个选择。

**![img](https://km.woa.com/files/photos/pictures/202107/1627281667_82_w695_h235.png)**

为了实现明文传输，如果直接去改加解密流程，对代码的入侵较大，如果考虑不周容易引入未知风险。为了尽量较少代码入侵以及维护原生实现的安全运行，我们将QuicFramer中的加解密套件选择处进行了hook，引入了FakeEncrypt/FakeDecrypt替换真实的加解密套件，以极小的入侵代价低成本的实现了明文传输。

![img](https://km.woa.com/files/photos/pictures/202107/1627281700_52_w589_h504.png)

在做完明文传输方案后，我们意识到由于这是一个非常底层的修改，对于客户端和服务端来需要高度一致的，要么双端都选择加密，要么双端都选择明文。如果双端不统一，则握手就会失败。为了使兼容性更好，减少运维成本和失败风险，我们在握手协商过程中，加入了明文传输的协商。

如下图流程，当前的握手过程，使用了AEAD这个tag标识了待协商的加密算法。

![img](https://km.woa.com/files/photos/pictures/202107/1627281743_26_w616_h499.png)

改进后，AEAD可以携带明文的加密算法，客户端如果也认可，则在下一次CHLO中选择该算法，则之后两边都进行明文传输。

![img](https://km.woa.com/files/photos/pictures/202107/1627281782_84_w516_h156.png)

![img](https://km.woa.com/files/photos/pictures/202107/1627281792_28_w527_h124.png)



### 6.2 连接迁移

前面背景已经介绍了连接迁移的基本原理，那是不是在Cronet中就直接可以用起来了呢?

我们在iOS下使用Cronet进行了一次切网尝试，通过抓包发现网络切换后，quic其实进行了重新握手，并没有如预期内的进行连接迁移。

![img](https://km.woa.com/files/photos/pictures/202107/1627281848_20_w783_h91.png)

通过代码分析原因后，我们发现Google其实并没有将连接迁移在各个系统版本上进行支持，仅在安卓平台“打折扣”的支持了，他们是在java层注册系统通知才能使用连接迁移，对于native的网络库以及其他操作系统是很不友好的。具体可参见我与google同学在论坛上的讨论：

https://groups.google.com/a/chromium.org/g/proto-quic/c/PVNFW9-I0Vo

既然原生实现并不好用，经过我们的改造，使用跨平台通用的内核层调用，达到了预期的效果，并且不依赖任何特定的操作系统组件。

在逐步的实践过程中，我们还发现，如果仅仅是切网时候发起连接迁移并不完美。有时候客户端处在弱网环境，wifi信号并未彻底断开，但传输数据实际上已经有损。为了解决这种场景下的问题，我们建立了一套弱网评估模型，通过主动探测和弱网评估进行启发式分析，在数据通道有损的情况下，尽可能早的主动进行连接迁移，减少对上层业务的影响。

通过研发跨平台通用的连接迁移，以及启发式主动迁移能力，最终在客户端看到的连接迁移效果如下，当切网发生时，连接并未断开，无需重连即可续传数据。

![img](https://km.woa.com/files/photos/pictures/202107/1627281892_72_w704_h202.png)

如下图，业务使用QUIC连接迁移后，业务对网络切换无感知，数据不中断。

![img](https://km.woa.com/files/photos/pictures/029/6dd6ef08b87e775d3d048c8a8ae06_w1122_h1222.png)

目前该功能已在腾讯会议长连接业务上全量上线，业务提升效果可参见文章[腾讯会议长连接的QUIC探索之路](https://km.woa.com/group/36460/articles/show/456703)。

或许有同学发现了，这里仅仅讲了连接迁移在客户端上的实现和效果，毕竟连接迁移后，客户端源IP发生了变化，云端接入层难道不需要做适配吗？答案是需要的，STGW作为公司云CLB和自研的主要七层网关接入，在QUIC连接迁移方面做了完整的解决方案，目前也已经将能力开放出来，在QUIC集群上全量上线。也欢迎大家试用。

### 6.3 完全0-RTT握手与金融级前向安全

如下是GQUIC的握手流程，原生实现里，应用发生冷启动时，首先会进行1RTT握手，拿到服务端的证书和ServerConfig（简称SCFG），随后SCFG会被作为随机数用于生成非前向安全的密钥。

因此在下一次发送数据包时，便可用非前向安全的密钥进行加密。直到收到了服务端发来的Server Hello后，通过类似DHE算法生成前向安全秘钥，自此开始发送前向安全的数据包。

![img](https://km.woa.com/files/photos/pictures/202107/1627282012_25_w712_h675.png)

在原生实现中，SCFG会被临时存储在进程内存堆区，下次发起新连接或者热启动时，直接就能进入0-RTT流程，但冷启动则永远是1-RTT。

基于原生的实现情况，我们针对握手流程做了两个方向的优化。

1. 实现100% 0-RTT成功率，用于在握手时延极其敏感的业务上，例如广告请求、API调用、短连接下载等。
2. 强制前向安全，针对安全敏感型业务，例如金融业务，0-RTT中发送的非前向安全数据包风险远高于前向安全数据包，因此对于金融型业务，可以强制1-RTT握手生产前向安全密钥后，再发送数据包。

改进后的两种握手流程如下图

![img](https://km.woa.com/files/photos/pictures/202107/1627282078_63_w520_h449.png)

### 6.4 实时传输功能

实时传输是QUIC的一个拓展功能，目前在IETF草稿阶段。实时传输适用于对数据可靠性要求不高，但非常注重数据实时性的业务。例如音视频传输、互动游戏等。实时传输在QUIC中的定位，以及与可靠传输的区别如下：

- 相同点

1. 在QUIC连接建立、创建QUIC数据包、数据加解密这些基础功能，不可靠数据与可靠数据都是共用的。
2. 实时传输也有拥塞控制、ACK机制，与可靠传输一致。

- 不同点

1. 实时传输数据不受滑动窗口限制，滑窗窗口满只限制可靠数据传输。
2. 发生丢包重传时，只重传可靠数据帧，实时数据帧不进行重传。
3. 实时数据没有quic stream概念，只是frame粒度

![img](https://km.woa.com/files/photos/pictures/202107/1627282164_64_w845_h487.png)

其中，一个关键点在于数据是否重传，IETF草稿的定义对这块比较开放，可以完全不重传，也可以选择性重传。

为此，TQUIC在实现实时传输时，做了灵活的改造，对于实时传输的数据，提供多种重传策略供使用者选择，可以完全不重传，也可以选择性重传某个重要的数据（比如关键帧），我们也在尝试做动态重传控制，依托我们的弱网判断模型，动态调整重传策略。有实时传输需求相关的业务可以联系我们试用。





## 七、总结及展望

经过STGW团队持续投入不停的打磨。腾讯会议信令长连接使用TQUIC传输xmpp协议，取代原有的tcp+tls方案，登录成功率由99.89%提升到了99.97%，登录时延下降了30%。腾讯视频在线广告请求成功率提升明显。云客户小红书通过CLB使用HTTP3后，延迟降低了23%。

![img](https://km.woa.com/files/photos/pictures/202107/1627282241_81_w533_h222.png)

附合作团队在QUIC方面的落地参考：[闪现社区APP网络优化](https://km.woa.com/articles/show/487155)、[腾讯会议长连接的QUIC探索之路](https://km.woa.com/group/36460/articles/show/456703)。我们的专门面向移动端的网络库也已经开源出来，欢迎大家共建：https://git.woa.com/stgw/tquic-sdk.git

文末最后，这里总结了过去几年，STGW团队在QUIC通用网络库方向的探索经验和进阶能力的持续打磨。一切过往皆为序章，我们深知这条路还有很长很长，接下来我们会继续基于QUIC深耕技术，给业务提供更通用、性能更强劲的网络传输解决方案。欢迎大家联系我们参与进来。

## 八、附录：参考与引用

- https://datatracker.ietf.org/doc/html/rfc9000
- https://datatracker.ietf.org/doc/draft-ietf-quic-datagram/?include_text=1
- https://docs.google.com/document/d/1g5nIXAIkN_Y-7XJW5K45IblHd_L2f5LTaDUDwvZ5L6g/edit
- https://km.woa.com/group/11879/articles/show/455095
- https://km.woa.com/group/36460/articles/show/456703https://km.woa.com/articles/show/487155













